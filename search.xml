<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello wworld</title>
    <url>/2025/04/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>代码001</title>
    <url>/2025/04/10/hdh/</url>
    <content><![CDATA[<h2 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h2><h5 id="fgf"><a href="#fgf" class="headerlink" title="fgf"></a>fgf</h5><h2 id="fsfs"><a href="#fsfs" class="headerlink" title="fsfs"></a>fsfs</h2><h3 id="fgd"><a href="#fgd" class="headerlink" title="fgd"></a>fgd</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">z</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>代码002</title>
    <url>/2025/04/15/nand2tetris-proj5-nopic/</url>
    <content><![CDATA[<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="RAM16K，Screen，Keyboard"><a href="#RAM16K，Screen，Keyboard" class="headerlink" title="RAM16K，Screen，Keyboard"></a>RAM16K，Screen，Keyboard</h3><blockquote>
<p>background</p>
</blockquote>
<ul>
<li><p><strong>8K &#x3D; 2的13次方。16K &#x3D; 2的14次方。</strong></p>
</li>
<li><p><strong>address[15] 表示 address 是一个 16 位的信号。</strong>address[15] 是第 1 位，<strong>address[0] 就是第 16 位。</strong></p>
</li>
<li><p><strong>RAM16K 的地址范围</strong>:**(16K)**（0到16383)需要 14 位地址来唯一标识每个存储单元，即 address[0..13] 这 14 位地址。</p>
</li>
<li><p><strong>Screen 的地址范围</strong>：**(8K)**（16384-24575）需要使用 13 位地址（address[0..12]）就可以满足其寻址需求。</p>
</li>
<li><p>可以明显看出，一个地址如果在0-16383内，它就属于 RAM16K 的地址空间；如果在16384-24575内，它就属于 Screen 的地址空间。所以<strong>它们的地址是分开的，没有重合。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP RAM16K &#123;</span><br><span class="line">    IN in[16], load, address[14];</span><br><span class="line">    OUT out[16];</span><br><span class="line">    // RAM16K是一个存储器，由16千个16-bit寄存器组成。</span><br><span class="line">    // 每次输入一个16位的数，RAM16K会根据其address决定将其存储到哪个位置。</span><br><span class="line">    // 具体的地址决定方法是：根据address的高2位（address[12..13]）选择一个4K的存储块，</span><br><span class="line">    // 然后根据低12位（address[0..11]）在所选的4K块内确定具体的存储位置。（以此类推，找到the only one）</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux4Way(in = load,sel = address[12..13],a = a,b = b,c = c,d = d);</span><br><span class="line">  </span><br><span class="line">    RAM4K(in=in , load=a , address=address[0..11] , out=outa );</span><br><span class="line">    RAM4K(in=in , load=b , address=address[0..11] , out=outb );</span><br><span class="line">    RAM4K(in=in , load=c , address=address[0..11] , out=outc );</span><br><span class="line">    RAM4K(in=in , load=d , address=address[0..11] , out=outd );</span><br><span class="line">    </span><br><span class="line">    Mux4Way16(a=outa , b=outb , c=outc , d=outd , sel=address[12..13] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Screen &#123;</span><br><span class="line"></span><br><span class="line">    IN  in[16],    // what to write</span><br><span class="line">    load,          // write-enable bit</span><br><span class="line">    address[13];   // where to read/write</span><br><span class="line">    OUT out[16];   // Screen value at the given address</span><br><span class="line"></span><br><span class="line">    BUILTIN Screen;</span><br><span class="line">    CLOCKED in, load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Keyboard&#123;</span><br><span class="line">    OUT out[16];</span><br><span class="line">    BUILTIN keyboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><img src="C:\Users\99512\Downloads\微信图片_20250415180524.jpg"  />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Memory &#123;</span><br><span class="line">    IN in[16], load, address[15];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux4Way(in=load, sel=address[13..14], a=ram1, b=ram2, c=scrn, d=keybd);</span><br><span class="line">    Or(a=ram1 , b=ram2, out=ram3);</span><br><span class="line">    RAM16K(in=in, load=ram3, address=address[0..13], out=ram );</span><br><span class="line">    Screen(in=in, load=scrn, address=address[0..12], out=sc);</span><br><span class="line">    Keyboard(out=kbd);</span><br><span class="line">    Mux4Way16(a=ram, b=ram, c=sc, d=kbd, sel=address[13..14], out=out);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414122921132.png" alt="image-20250414122921132" style="zoom:25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414123504372.png" alt="image-20250414123504372" style="zoom:25%;" /></p>
<p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250408152923618.png" alt="image-20250408152923618" style="zoom:25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250406111659071.png" alt="image-20250406111659071" style="zoom:25%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP CPU &#123;</span><br><span class="line"></span><br><span class="line">    IN  inM[16],         // M value input  (M = contents of RAM[A])</span><br><span class="line">        instruction[16], // Instruction for execution</span><br><span class="line">        reset;           // Signals whether to re-start the current</span><br><span class="line">                         // program (reset==1) or continue executing</span><br><span class="line">                         // the current program (reset==0).</span><br><span class="line"></span><br><span class="line">    OUT outM[16],        // M value output</span><br><span class="line">        writeM,          // Write to M? </span><br><span class="line">        addressM[15],    // Address in data memory (of M)</span><br><span class="line">        pc[15];          // address of next instruction</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">	// A-register 可能执行 A/C 指令</span><br><span class="line">    // A instruction</span><br><span class="line">    // @3001</span><br><span class="line">    // [0]000101110111001</span><br><span class="line">     </span><br><span class="line">     // 用途一：将常数输入计算机</span><br><span class="line">     // 用途二：为 C - 指令提供目标数据内存单元的地址（放入 A 寄存器）</span><br><span class="line">     // 用途三：为跳转指令提供目的地址</span><br><span class="line">    </span><br><span class="line">    Not(in=instruction[15] , out=notop ); </span><br><span class="line">    Mux16(a=aluOut, b=instruction , sel=notop , out=q1 ); 	 </span><br><span class="line">    Or(a=instruction[5] , b=notop , out=intoA );  </span><br><span class="line">    ARegister(in=q1, load=intoA, out=A,out[0..14]=addressM); // 同时储存并输出addressM </span><br><span class="line">    		</span><br><span class="line">    And(a=instruction[15] , b=instruction[12] , out=AMSwitch ); </span><br><span class="line">    Mux16(a=A , b=inM , sel=AMSwitch , out=AM );</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    // C instruction</span><br><span class="line">    // i  _  _  a  c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3</span><br><span class="line">    // 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00</span><br><span class="line">    // ins[5]是C指令中的dest指令(=1表示去A寄存器)</span><br><span class="line">    // ins[12]是a=0/1，用于在 C指令中 决定是使用 A寄存器的值（A）还是内存的值（inM）（A指令时直接用inM了）</span><br><span class="line">    </span><br><span class="line">    And(a=instruction[15] , b=instruction[4] , out=intoD );</span><br><span class="line">    DRegister(in=aluOut , load=intoD , out=D ); // D 寄存器：for数据暂存</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\99512\Downloads\微信图片_20250415200024.jpg"></p>
<img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250408153509769.png" alt="image-20250408153509769"  />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // ALU</span><br><span class="line">    // ALU takes input from DRegister and from ARegister or inM</span><br><span class="line">    // addressM 是用来确定从哪里读取数据，而 inM 是实际读取到的数据。</span><br><span class="line">    // ALU的zx,nx,zy,ny,f,no这些控制信号是由操作码 c1 - c6 经过一定逻辑转换得到的，所以C指令进不去A寄存器，但是ALU也是能获得其操作码进行操作的。</span><br><span class="line">    ALU(x=D, y=AM, out=aluOut, out=outM,</span><br><span class="line">        zx=instruction[11],</span><br><span class="line">        nx=instruction[10],</span><br><span class="line">        zy=instruction[9],</span><br><span class="line">        ny=instruction[8],</span><br><span class="line">        f=instruction[7],</span><br><span class="line">        no=instruction[6],</span><br><span class="line">        zr=zrOut,</span><br><span class="line">        ng=ngOut</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // writeM</span><br><span class="line">    And(a=instruction[15] , b=instruction[3] , out=writeM );</span><br><span class="line"></span><br><span class="line">    // PC </span><br><span class="line">    // load设置</span><br><span class="line">    Not(in=ngOut , out=pos );</span><br><span class="line">    Not(in=zrOut , out=nzr );</span><br><span class="line"></span><br><span class="line">    // 处理JGT条件(&gt;0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[0] , out=jgt );</span><br><span class="line">    And(a=pos , b=nzr , out=posnzr );</span><br><span class="line">    And(a=jgt , b=posnzr , out=ld1 ); </span><br><span class="line"></span><br><span class="line">    // 处理JEQ条件(=0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[1] , out=jeq );</span><br><span class="line">    And(a=jeq , b=zrOut , out=ld2 ); </span><br><span class="line"></span><br><span class="line">    // 处理JLT条件(&lt;0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[2] , out=jlt );</span><br><span class="line">    And(a=jlt , b=ngOut , out=ld3 );</span><br><span class="line"></span><br><span class="line">    //合并跳转条件</span><br><span class="line">    Or(a=ld1 , b=ld2 , out=ldt ); </span><br><span class="line">    Or(a=ld3 , b=ldt , out=loadd );</span><br><span class="line"></span><br><span class="line">    PC(in=A , load=loadd , inc=true , reset=reset , out[0..14]=pc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 内存根据 PC 提供的地址，将对应地址处的指令输出为 instruction。</span><br><span class="line">// 但这并不是 PC 输出后被写入 RAM ，而是 PC 提供一个地址索引，内存根据这个索引将存储在该地址的指令数据输出。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414193356928.png" alt="image-20250414193356928" style="zoom: 25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414130853170.png" alt="image-20250414130853170" style="zoom:25%;" /></p>
<h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Computer &#123;</span><br><span class="line"></span><br><span class="line">    IN reset;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    ROM32K(address=pc , out=instruction );</span><br><span class="line">    CPU(inM=inM, instruction=instruction , reset=reset , outM=outM , writeM=writeM , addressM=addressM , pc=pc );</span><br><span class="line">    Memory(in=outM , load=writeM , address=addressM , out=inM );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>LOK</title>
    <url>/2025/04/11/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%972/</url>
    <content><![CDATA[<p><img src="https://picsum.photos/id/627/200/300" alt="图片名称八个字"></p>
]]></content>
  </entry>
</search>
