<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABC</title>
    <url>/2025/05/01/ABC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>代码001</title>
    <url>/2025/04/10/hdh/</url>
    <content><![CDATA[<h2 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h2><h5 id="fgf"><a href="#fgf" class="headerlink" title="fgf"></a>fgf</h5><h2 id="fsfs"><a href="#fsfs" class="headerlink" title="fsfs"></a>fsfs</h2><h3 id="fgd"><a href="#fgd" class="headerlink" title="fgd"></a>fgd</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">z</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/2025/04/09/helloworld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>proj1</title>
    <url>/2025/04/19/nand2tetris-proj1-final/</url>
    <content><![CDATA[<h2 id="Proj1"><a href="#Proj1" class="headerlink" title="Proj1"></a>Proj1</h2><h3 id="1-1-Boolean-Logic"><a href="#1-1-Boolean-Logic" class="headerlink" title="1.1 Boolean Logic"></a>1.1 Boolean Logic</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141214589.png" alt="image-20250404141214589"></p>
<p>⭐<strong>Some useful equations</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141414517.png" alt="image-20250404141414517"></p>
<p><strong>→Boolean Algebra  can be 化简</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141608949.png" alt="image-20250404141608949"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141759670.png" alt="image-20250404141759670"></p>
<p>（Two way : ①equations,②write down the truth table)</p>
<h3 id="1-2-Boolean-Function"><a href="#1-2-Boolean-Function" class="headerlink" title="1.2 Boolean Function"></a>1.2 Boolean Function</h3><h4 id="001："><a href="#001：" class="headerlink" title="001："></a>001：</h4><ul>
<li><strong>理论上，任何布尔函数都可以用NotAndOr等表示出来（通过真值表选取f&#x3D;1的情况）（做芯片有用）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142330760.png" alt="image-20250404142330760"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142531366.png" alt="image-20250404142531366"></p>
<h4 id="002："><a href="#002：" class="headerlink" title="002："></a>002：</h4><ul>
<li><strong>（or可以通过And和Not表示）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142856026.png" alt="image-20250404142856026"></p>
<h4 id="003："><a href="#003：" class="headerlink" title="003："></a>003：</h4><ul>
<li><strong>而Nand可以表示出AndNot芯片（根本的根本）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142922081.png" alt="image-20250404142922081"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404144646895.png" alt="image-20250404144646895"></p>
<h3 id="1-3-Logic-Gates"><a href="#1-3-Logic-Gates" class="headerlink" title="1.3 Logic Gates"></a>1.3 Logic Gates</h3><p><em>上一节是抽象的逻辑运算，这一节是<strong>实际的</strong>芯片&#x2F;逻辑门</em></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145506478.png" alt="image-20250404145506478"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145701379.png" alt="image-20250404145701379"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145744036.png" alt="image-20250404145744036"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145815647.png" alt="image-20250404145815647"></p>
<p><strong>一个接口，可以有不同的实现</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150147322.png" alt="image-20250404150147322"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150426261.png" alt="image-20250404150426261"></p>
<h3 id="1-4-Hardware-Description-Language"><a href="#1-4-Hardware-Description-Language" class="headerlink" title="1.4 Hardware Description Language"></a>1.4 Hardware Description Language</h3><p><strong>一种硬件描述语言（做硬件&#x2F;芯片用的）</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150718865.png" alt="image-20250404150718865"></p>
<p><strong>芯片接口 和 芯片实现</strong></p>
<p>⭐<strong>实现：用真值表看1，写出布尔函数化简，画出逻辑图</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404151805805.png" alt="image-20250404151805805"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404152954069.png" alt="image-20250404152954069"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404153644134.png" alt="image-20250404153644134"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404154013569.png" alt="image-20250404154013569"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404154041022.png" alt="image-20250404154041022"></p>
<h3 id="1-5-Hardware-Simulation"><a href="#1-5-Hardware-Simulation" class="headerlink" title="1.5 Hardware Simulation"></a>1.5 Hardware Simulation</h3><ul>
<li><strong>for 模拟芯片测试</strong><ul>
<li>way：在给定的硬件模拟器中 + 使用编写的测试文件</li>
</ul>
</li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404160947915.png" alt="image-20250404160947915"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404163421803.png" alt="image-20250404163421803"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404170858647.png" alt="image-20250404170858647"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404172732071.png" alt="image-20250404172732071"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404172955446.png" alt="image-20250404172955446"></p>
<h3 id="1-6-Mutil-bit-Buses"><a href="#1-6-Mutil-bit-Buses" class="headerlink" title="1.6 Mutil-bit Buses"></a>1.6 Mutil-bit Buses</h3><p><strong>多位总线（eg16位总线，一条线上有16个位bit）</strong></p>
<p>（最左边第一位是高位。 最右边的最低位一般标记为第 0 位）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202521312.png" alt="image-20250404202521312"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202530048.png" alt="image-20250404202530048"></p>
<p><strong>⭐ useful</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202602223.png" alt="image-20250404202602223"></p>
<p>说明中第一句的意思是：<strong>可以进行多个output，比如前8位输出，后八位输出，全部输出</strong></p>
<h3 id="1-7-proj-7-preview"><a href="#1-7-proj-7-preview" class="headerlink" title="1.7 proj 7  preview"></a>1.7 proj 7  preview</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202849141.png" alt="image-20250404202849141"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202926080.png" alt="image-20250404202926080"></p>
<p><strong>tip几个</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203025658.png" alt="image-20250404203025658"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203159712.png" alt="image-20250404203159712"></p>
<p>（既可以用作And门，也可以用作Mux门）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203425278.png" alt="image-20250404203425278"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204239746.png" alt="image-20250404204239746"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204625628.png" alt="image-20250404204625628"></p>
<p><strong>And 16 ： 两个输入，都是16位的，一个输出（每位进行And运算），也是十六位的</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204739365.png" alt="image-20250404204739365"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204849942.png" alt="image-20250404204849942"></p>
<p><strong>16-bit，4way multiplexor : 输入都是16位的，4个输入，一个16bit输出（mux逻辑，根据which sel进行选择）。</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404205018344.png" alt="image-20250404205018344"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404205126035.png" alt="image-20250404205126035"></p>
<p>⭐ <strong>notes</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404210112492.png" alt="image-20250404210112492"></p>
<p> <strong>API</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404211743753.png" alt="image-20250404211743753"></p>
<h3 id="1-8-code"><a href="#1-8-code" class="headerlink" title="1.8 code"></a>1.8 code</h3><h4 id="Nand"><a href="#Nand" class="headerlink" title="Nand"></a>Nand</h4><table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>out</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Not gate : if (in) out = 0, else out = 1</span><br><span class="line"></span><br><span class="line">CHIP Not &#123;</span><br><span class="line">    IN in;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=in, b=in, out=out);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="And"><a href="#And" class="headerlink" title="And"></a>And</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// And gate : if (a and b) out = 1, else out = 0 </span><br><span class="line"></span><br><span class="line">CHIP And &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=a, b=b, out=c);</span><br><span class="line">    Not(in=c,out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or"><a href="#Or" class="headerlink" title="Or"></a>Or</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/b75694b72e0957867d154be60f9a207.jpg" alt="b75694b72e0957867d154be60f9a207" style="zoom:10%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Or gate : if (a or b) out = 1, else out = 0 </span><br><span class="line">// only a=0,b=0,out=0,else out=1</span><br><span class="line"></span><br><span class="line">CHIP Or &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=a, b=a, out=a2);</span><br><span class="line">    Nand(a=b, b=b, out=b2);</span><br><span class="line">    Nand(a=a2, b=b2,out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Xor"><a href="#Xor" class="headerlink" title="Xor"></a>Xor</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/14c146587d40e107bec5f52c50fc019.jpg" alt="14c146587d40e107bec5f52c50fc019" style="zoom:12%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exclusive-or gate: if ((a and Not(b)) or (Not(a) and b)) out = 1, else out = 0</span><br><span class="line"></span><br><span class="line">CHIP Xor &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    ////真值表推出来的(定义也写明了哈哈哈)</span><br><span class="line">    Not(in=a, out=nota);</span><br><span class="line">    Not(in=b, out=notb);</span><br><span class="line">    And(a=a, b=notb, out=aAndnotb);</span><br><span class="line">    And(a=b, b=nota, out=bAndnota);</span><br><span class="line">    Or(a=aAndnotb, b=bAndnota, out=out);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="Mux（二1bit并一）"><a href="#Mux（二1bit并一）" class="headerlink" title="Mux（二1bit并一）"></a>Mux（二1bit并一）</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/bb2b12af45a30fae8396224ade119a7.jpg" alt="bb2b12af45a30fae8396224ade119a7" style="zoom:11%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Multiplexor: if (sel = 0) out = a, else out = b  (good!)</span><br><span class="line"></span><br><span class="line">CHIP Mux &#123;</span><br><span class="line">    IN a, b, sel;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel, out=notsel); </span><br><span class="line">    And(a=a , b=notsel, out=outa);//if sel==0,返回a (depend on a)</span><br><span class="line">    And(a=sel, b=b, out=outb ); //if sel==1，返回b (depend on b)</span><br><span class="line">    Or(a=outa, b=outb, out=out );   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dmux（一解二）"><a href="#Dmux（一解二）" class="headerlink" title="Dmux（一解二）"></a>Dmux（一解二）</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/1c6ff7a10f0431156d30ca2e457635b.jpg" alt="1c6ff7a10f0431156d30ca2e457635b" style="zoom:12%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Demultiplexor: [a, b] = 		[in, 0] if sel = 0 		[0, in] if sel = 1</span><br><span class="line"></span><br><span class="line">CHIP DMux &#123;</span><br><span class="line">    IN in, sel;</span><br><span class="line">    OUT a, b;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel , out=notsel );</span><br><span class="line">    And(a=in, b=notsel, out=a );</span><br><span class="line">    And(a=in, b=sel , out=b ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Not16"><a href="#Not16" class="headerlink" title="Not16"></a>Not16</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/2888a1bdd8c56821dc4950f143b6396.jpg" alt="2888a1bdd8c56821dc4950f143b6396" style="zoom:15%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit Not gate:		for i = 0, ..., 15: 	out[i] = Not(a[i])</span><br><span class="line"> </span><br><span class="line">// 把一个16位的数，每一位都取反</span><br><span class="line">CHIP Not16 &#123;</span><br><span class="line">    IN in[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=in[0] , out=out[0] );</span><br><span class="line">    Not(in=in[1] , out=out[1] );</span><br><span class="line">    Not(in=in[2] , out=out[2] );</span><br><span class="line">    Not(in=in[3] , out=out[3] );</span><br><span class="line">    Not(in=in[4] , out=out[4] );</span><br><span class="line">    Not(in=in[5] , out=out[5] );</span><br><span class="line">    Not(in=in[6] , out=out[6] );</span><br><span class="line">    Not(in=in[7] , out=out[7] );</span><br><span class="line">    Not(in=in[8] , out=out[8] );</span><br><span class="line">    Not(in=in[9] , out=out[9] );</span><br><span class="line">    Not(in=in[10] , out=out[10] );</span><br><span class="line">    Not(in=in[11] , out=out[11] );</span><br><span class="line">    Not(in=in[12] , out=out[12] );</span><br><span class="line">    Not(in=in[13] , out=out[13] );</span><br><span class="line">    Not(in=in[14] , out=out[14] );</span><br><span class="line">    Not(in=in[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="And16"><a href="#And16" class="headerlink" title="And16"></a>And16</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit And gate: 	for i = 0, ..., 15: 	out[i] = a[i] And b[i] </span><br><span class="line"></span><br><span class="line">// 把两个16位的数，每一位都求And</span><br><span class="line">CHIP And16 &#123;</span><br><span class="line">    IN a[16], b[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    //// Replace this comment with your code.</span><br><span class="line">    And(a=a[0] , b=b[0] , out=out[0] );</span><br><span class="line">    And(a=a[1] , b=b[1] , out=out[1] );</span><br><span class="line">    And(a=a[2] , b=b[2] , out=out[2] );</span><br><span class="line">    And(a=a[3] , b=b[3] , out=out[3] );</span><br><span class="line">    And(a=a[4] , b=b[4] , out=out[4] );</span><br><span class="line">    And(a=a[5] , b=b[5] , out=out[5] );</span><br><span class="line">    And(a=a[6] , b=b[6] , out=out[6] );</span><br><span class="line">    And(a=a[7] , b=b[7] , out=out[7] );</span><br><span class="line">    And(a=a[8] , b=b[8] , out=out[8] );</span><br><span class="line">    And(a=a[9] , b=b[9] , out=out[9] );</span><br><span class="line">    And(a=a[10] , b=b[10] , out=out[10] );</span><br><span class="line">    And(a=a[11] , b=b[11] , out=out[11] );</span><br><span class="line">    And(a=a[12] , b=b[12] , out=out[12] );</span><br><span class="line">    And(a=a[13] , b=b[13] , out=out[13] );</span><br><span class="line">    And(a=a[14] , b=b[14] , out=out[14] );</span><br><span class="line">    And(a=a[15] , b=b[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or16"><a href="#Or16" class="headerlink" title="Or16"></a>Or16</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit Or gate: 		for i = 0, ..., 15: 	out[i] = a[i] Or b[i] </span><br><span class="line"></span><br><span class="line">CHIP Or16 &#123;</span><br><span class="line">    IN a[16], b[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Or(a=a[0] , b=b[0] , out=out[0] );</span><br><span class="line">    Or(a=a[1] , b=b[1] , out=out[1] );</span><br><span class="line">    Or(a=a[2] , b=b[2] , out=out[2] );</span><br><span class="line">    Or(a=a[3] , b=b[3] , out=out[3] );</span><br><span class="line">    Or(a=a[4] , b=b[4] , out=out[4] );</span><br><span class="line">    Or(a=a[5] , b=b[5] , out=out[5] );</span><br><span class="line">    Or(a=a[6] , b=b[6] , out=out[6] );</span><br><span class="line">    Or(a=a[7] , b=b[7] , out=out[7] );</span><br><span class="line">    Or(a=a[8] , b=b[8] , out=out[8] );</span><br><span class="line">    Or(a=a[9] , b=b[9] , out=out[9] );</span><br><span class="line">    Or(a=a[10] , b=b[10] , out=out[10] );</span><br><span class="line">    Or(a=a[11] , b=b[11] , out=out[11] );</span><br><span class="line">    Or(a=a[12] , b=b[12] , out=out[12] );</span><br><span class="line">    Or(a=a[13] , b=b[13] , out=out[13] );</span><br><span class="line">    Or(a=a[14] , b=b[14] , out=out[14] );</span><br><span class="line">    Or(a=a[15] , b=b[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux16（二16bit并一）"><a href="#Mux16（二16bit并一）" class="headerlink" title="Mux16（二16bit并一）"></a>Mux16（二16bit并一）</h4><ul>
<li>实现方式：16个Mux并排作用与每一个bit</li>
</ul>
<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/e37fe587999c0d2944e788df5cbfd59.jpg" alt="e37fe587999c0d2944e788df5cbfd59" style="zoom:13%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit multiplexor: 		for i = 0, ..., 15:	   if (sel = 0) out[i] = a[i], else out[i] = b[i]</span><br><span class="line"></span><br><span class="line">CHIP Mux16 &#123;</span><br><span class="line">    IN a[16], b[16], sel;</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel , out=notsel );</span><br><span class="line"></span><br><span class="line">    And(a=a[0] , b=notsel , out=out01 );</span><br><span class="line">    And(a=sel , b=b[0] , out=out02 );</span><br><span class="line">    Or(a=out01 , b=out02 , out=out[0] );</span><br><span class="line"></span><br><span class="line">    And(a=a[1] , b=notsel , out=out11 );</span><br><span class="line">    And(a=sel , b=b[1] , out=out12 );</span><br><span class="line">    Or(a=out11 , b=out12 , out=out[1] );</span><br><span class="line"></span><br><span class="line">    And(a=a[2] , b=notsel , out=out21 );</span><br><span class="line">    And(a=sel , b=b[2] , out=out22 );</span><br><span class="line">    Or(a=out21 , b=out22 , out=out[2] );</span><br><span class="line"></span><br><span class="line">    And(a=a[3] , b=notsel , out=out31 );</span><br><span class="line">    And(a=sel , b=b[3] , out=out32 );</span><br><span class="line">    Or(a=out31 , b=out32 , out=out[3] );</span><br><span class="line"></span><br><span class="line">    And(a=a[4] , b=notsel , out=out41 );</span><br><span class="line">    And(a=sel , b=b[4] , out=out42 );</span><br><span class="line">    Or(a=out41 , b=out42 , out=out[4] );</span><br><span class="line"></span><br><span class="line">    And(a=a[5] , b=notsel , out=out51 );</span><br><span class="line">    And(a=sel , b=b[5] , out=out52 );</span><br><span class="line">    Or(a=out51 , b=out52 , out=out[5] );</span><br><span class="line"></span><br><span class="line">    And(a=a[6] , b=notsel , out=out61 );</span><br><span class="line">    And(a=sel , b=b[6] , out=out62 );</span><br><span class="line">    Or(a=out61 , b=out62 , out=out[6] );</span><br><span class="line"></span><br><span class="line">    And(a=a[7] , b=notsel , out=out71 );</span><br><span class="line">    And(a=sel , b=b[7] , out=out72 );</span><br><span class="line">    Or(a=out71 , b=out72 , out=out[7] );</span><br><span class="line"></span><br><span class="line">    And(a=a[8] , b=notsel , out=out81 );</span><br><span class="line">    And(a=sel , b=b[8] , out=out82 );</span><br><span class="line">    Or(a=out81 , b=out82 , out=out[8] );</span><br><span class="line"></span><br><span class="line">    And(a=a[9] , b=notsel , out=out91 );</span><br><span class="line">    And(a=sel , b=b[9] , out=out92 );</span><br><span class="line">    Or(a=out91 , b=out92 , out=out[9] );</span><br><span class="line"></span><br><span class="line">    And(a=a[10] , b=notsel , out=out101 );</span><br><span class="line">    And(a=sel , b=b[10] , out=out102 );</span><br><span class="line">    Or(a=out101 , b=out102 , out=out[10] );</span><br><span class="line"></span><br><span class="line">    And(a=a[11] , b=notsel , out=out111 );</span><br><span class="line">    And(a=sel , b=b[11] , out=out112 );</span><br><span class="line">    Or(a=out111 , b=out112 , out=out[11] );</span><br><span class="line"></span><br><span class="line">    And(a=a[12] , b=notsel , out=out121 );</span><br><span class="line">    And(a=sel , b=b[12] , out=out122 );</span><br><span class="line">    Or(a=out121 , b=out122 , out=out[12] );</span><br><span class="line"></span><br><span class="line">    And(a=a[13] , b=notsel , out=out131 );</span><br><span class="line">    And(a=sel , b=b[13] , out=out132 );</span><br><span class="line">    Or(a=out131 , b=out132 , out=out[13] );</span><br><span class="line"></span><br><span class="line">    And(a=a[14] , b=notsel , out=out141 );</span><br><span class="line">    And(a=sel , b=b[14] , out=out142 );</span><br><span class="line">    Or(a=out141 , b=out142 , out=out[14] );</span><br><span class="line"></span><br><span class="line">    And(a=a[15] , b=notsel , out=out151 );</span><br><span class="line">    And(a=sel , b=b[15] , out=out152 );</span><br><span class="line">    Or(a=out151 , b=out152 , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or8Way"><a href="#Or8Way" class="headerlink" title="Or8Way"></a>Or8Way</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/1113aa3384d980cf7a3cf7c22f999ea.jpg" alt="1113aa3384d980cf7a3cf7c22f999ea" style="zoom:11%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 8-way Or gate！  		out = in[0] Or in[1] Or ... Or in[7]</span><br><span class="line">// 输入 一个 8-bit数！而不是 两个 ！输出一个1-bit数。</span><br><span class="line"></span><br><span class="line">CHIP Or8Way &#123;</span><br><span class="line">    IN in[8];</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    // 输入一个八位（bit）数，依次每两位取Or，最后输出结果（全0才会输出0，有一个1就输出1）</span><br><span class="line">    Or(a=in[0] , b=in[1] , out=s1 );</span><br><span class="line">    Or(a=in[2] , b=in[3] , out=s2 );</span><br><span class="line">    Or(a=in[4] , b=in[5] , out=s3 );</span><br><span class="line">    Or(a=in[6] , b=in[7] , out=s4 );</span><br><span class="line">    Or(a=s1 , b=s2 , out=w1 );</span><br><span class="line">    Or(a=s3 , b=s4 , out=w2 );</span><br><span class="line">    Or(a=w1 , b=w2 , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux4Way16（四16bit并一）"><a href="#Mux4Way16（四16bit并一）" class="headerlink" title="Mux4Way16（四16bit并一）"></a>Mux4Way16（四16bit并一）</h4><ul>
<li><p>解析名字含义：</p>
<ul>
<li><p><strong>Mux16</strong> 是 <strong>16-bit</strong> 的意思。</p>
</li>
<li><p><strong>Mux4Way16</strong> 是 <strong>16-bit，4-way</strong> 的意思</p>
</li>
<li><p>那为啥 Or8Way 是 8-bit，1-way？的意思？</p>
</li>
</ul>
</li>
</ul>
<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/412c8358a3261cc20cca4fb7d9437aa.jpg" alt="412c8358a3261cc20cca4fb7d9437aa" style="zoom:11%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4-way 16-bit multiplexor:</span><br><span class="line"> * out = a if sel = 00</span><br><span class="line"> *       b if sel = 01</span><br><span class="line"> *       c if sel = 10</span><br><span class="line"> *       d if sel = 11</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 四条路/输入，每个都是16bit，根据sel的不同（4个sel，两位的二进制数字），输出其中 一 个数。</span><br><span class="line">CHIP Mux4Way16 &#123; 							// 看成 Mux 16 ，把 4Way 插在名字中间</span><br><span class="line">    IN a[16], b[16], c[16], d[16], sel[2];</span><br><span class="line">    OUT out[16];</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    // we just need one output !</span><br><span class="line">    Mux16(a=a , b=b , sel=sel[0] , out=w1 );   // [0]是最右</span><br><span class="line">    Mux16(a=c , b=d , sel=sel[0] , out=w2 );</span><br><span class="line"></span><br><span class="line">    Mux16(a=w1 , b=w2 , sel=sel[1] , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux8Way16（八16bit并一）"><a href="#Mux8Way16（八16bit并一）" class="headerlink" title="Mux8Way16（八16bit并一）"></a>Mux8Way16（八16bit并一）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 8-way 16-bit multiplexor:</span><br><span class="line"> * out = a if sel = 000</span><br><span class="line"> *       b if sel = 001</span><br><span class="line"> *       c if sel = 010</span><br><span class="line"> *       d if sel = 011</span><br><span class="line"> *       e if sel = 100</span><br><span class="line"> *       f if sel = 101</span><br><span class="line"> *       g if sel = 110</span><br><span class="line"> *       h if sel = 111</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 8条路/输入，每个都是16bit，根据sel的不同（8个sel，三位的二进制数字），输出其中 一 个数。</span><br><span class="line">CHIP Mux8Way16 &#123;</span><br><span class="line">    IN a[16], b[16], c[16], d[16],</span><br><span class="line">       e[16], f[16], g[16], h[16],</span><br><span class="line">       sel[3];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    // 用两个Mux4Way16再加上一个Mux16就行了。</span><br><span class="line">    Mux4Way16(a=a , b=b , c=c , d=d , sel[0]=sel[0] ,sel[1]=sel[1],out=w1 );</span><br><span class="line">    Mux4Way16(a=e , b=f , c=g , d=h , sel[0]=sel[0] ,sel[1]=sel[1],out=w2 );</span><br><span class="line">    Mux16(a=w1 , b=w2 , sel=sel[2] , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMux4Way（一解四）"><a href="#DMux4Way（一解四）" class="headerlink" title="DMux4Way（一解四）"></a>DMux4Way（一解四）</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/042760ad0a8f3a0d172d509e6a2462e.jpg" alt="042760ad0a8f3a0d172d509e6a2462e" style="zoom:15%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4-way demultiplexor:</span><br><span class="line"> * [a, b, c, d] = [in, 0, 0, 0] if sel = 00</span><br><span class="line"> *                [0, in, 0, 0] if sel = 01</span><br><span class="line"> *                [0, 0, in, 0] if sel = 10</span><br><span class="line"> *                [0, 0, 0, in] if sel = 11</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 一个输入（几bit应该没要求），根据sel的不同选择赋予abcd哪个的值（4个值4Way，需要4个sel），其他值输出0（4个sel，两位二进制数字）</span><br><span class="line">CHIP DMux4Way &#123;</span><br><span class="line">    IN in, sel[2];</span><br><span class="line">    OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux(in=in, sel=sel[1], a=top, b=bottom);</span><br><span class="line">    </span><br><span class="line">    DMux(in=top, sel=sel[0], a=a, b=b);</span><br><span class="line">    DMux(in=bottom, sel=sel[0], a=c, b=d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMux8Way（一解八）"><a href="#DMux8Way（一解八）" class="headerlink" title="DMux8Way（一解八）"></a>DMux8Way（一解八）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 8-way demultiplexor:</span><br><span class="line"> * [a, b, c, d, e, f, g, h] = [in, 0,  0,  0,  0,  0,  0,  0] if sel = 000</span><br><span class="line"> *                            [0, in,  0,  0,  0,  0,  0,  0] if sel = 001</span><br><span class="line"> *                            [0,  0, in,  0,  0,  0,  0,  0] if sel = 010</span><br><span class="line"> *                            [0,  0,  0, in,  0,  0,  0,  0] if sel = 011</span><br><span class="line"> *                            [0,  0,  0,  0, in,  0,  0,  0] if sel = 100</span><br><span class="line"> *                            [0,  0,  0,  0,  0, in,  0,  0] if sel = 101</span><br><span class="line"> *                            [0,  0,  0,  0,  0,  0, in,  0] if sel = 110</span><br><span class="line"> *                            [0,  0,  0,  0,  0,  0,  0, in] if sel = 111</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 根据三位数的sel把in分成8部分</span><br><span class="line">CHIP DMux8Way &#123;</span><br><span class="line">    IN in, sel[3]; </span><br><span class="line">    // sel有8种可能，但打开时，只有一种状态，所以只有一个有值，其他都是0值。</span><br><span class="line">    OUT a, b, c, d, e, f, g, h;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    // 根据sel第一位，把in数据分成两部分，top和bottom</span><br><span class="line">    DMux(in=in, sel=sel[2], a=top, b=bottom);</span><br><span class="line"></span><br><span class="line">    // 根据sel第二位，分别把top和bottom再分成两个部分，总计四部分</span><br><span class="line">    DMux(in=top, sel=sel[1], a=w1, b=w2);</span><br><span class="line">    DMux(in=bottom, sel=sel[1], a=w3, b=w4);</span><br><span class="line"></span><br><span class="line">    // 根据sel第三位，把in总共分成8部分    </span><br><span class="line">    DMux(in=w1, sel=sel[0], a=a, b=b);</span><br><span class="line">    DMux(in=w2, sel=sel[0], a=c, b=d);</span><br><span class="line"></span><br><span class="line">    DMux(in=w3, sel=sel[0], a=e, b=f);</span><br><span class="line">    DMux(in=w4, sel=sel[0], a=g, b=h);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>proj2</title>
    <url>/2025/05/01/nand2tetris-proj2-final/</url>
    <content><![CDATA[<h3 id="2-1-Binary-Numbers"><a href="#2-1-Binary-Numbers" class="headerlink" title="2.1 Binary Numbers"></a>2.1 Binary Numbers</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164423371.png" alt="image-20250405164423371"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163338004.png" alt="image-20250405163338004"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163415418.png" alt="image-20250405163415418"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163504925.png" alt="image-20250405163504925"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163628278.png" alt="image-20250405163628278"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163712469.png" alt="image-20250405163712469"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405163835567.png" alt="image-20250405163835567"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164037453.png" alt="image-20250405164037453"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164111279.png" alt="image-20250405164111279"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164323993.png" alt="image-20250405164323993"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164440667.png" alt="image-20250405164440667"></p>
<h3 id="2-2-Binary-Addtion"><a href="#2-2-Binary-Addtion" class="headerlink" title="2.2 Binary Addtion"></a>2.2 Binary Addtion</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164738887.png" alt="image-20250405164738887"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405164824580.png" alt="image-20250405164824580"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165448779.png" alt="image-20250405165448779"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165500123.png" alt="image-20250405165500123"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165606105.png" alt="image-20250405165606105"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165703426.png"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165723071.png" alt="image-20250405165723071"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165825413.png" alt="image-20250405165825413"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405165845990.png" alt="image-20250405165845990"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170123908.png" alt="image-20250405170123908"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170129544.png" alt="image-20250405170129544"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170208503.png" alt="image-20250405170208503"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170216151.png" alt="image-20250405170216151"></p>
<h3 id="2-3-Negative-Numbers"><a href="#2-3-Negative-Numbers" class="headerlink" title="2.3 Negative Numbers"></a>2.3 Negative Numbers</h3><h4 id="Expression-of-negative-numbers"><a href="#Expression-of-negative-numbers" class="headerlink" title="Expression of negative numbers"></a>Expression of negative numbers</h4><p>way1</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170630309.png" alt="image-20250405170630309"></p>
<p>way2：</p>
<p><strong>前一半的二进制数字（0-7）用来表示正数，后一半的二进制数字（8-15）留作表示负数（eg 表示-3，16-3&#x3D;13）</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170802386.png" alt="image-20250405170802386"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405170839174.png" alt="image-20250405170839174"></p>
<h4 id="Addtion-in-2’s-Complement"><a href="#Addtion-in-2’s-Complement" class="headerlink" title="Addtion in 2’s Complement"></a>Addtion in 2’s Complement</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405171005000.png" alt="image-20250405171005000"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405171035760.png" alt="image-20250405171035760"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405171049696.png" alt="image-20250405171049696"></p>
<p>-2+(-3)&#x3D;-5,-5的补码就是11（1011）</p>
<h4 id="Computing-x"><a href="#Computing-x" class="headerlink" title="Computing -x"></a>Computing -x</h4><ul>
<li>Eg算-4的二进制表达：4&#x3D;100，1111-0100（1111怎么来的，令n&#x3D;4(意味着用4位二进制数来表示值））</li>
<li>取反码：1111-0100&#x3D;1011，求补码：1011+1&#x3D;1100</li>
<li>1100&#x3D;12，就是4的补码（16-4&#x3D;2）</li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172020903.png" alt="image-20250405172020903"></p>
<h4 id="Eg"><a href="#Eg" class="headerlink" title="Eg"></a>Eg</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172052564.png" alt="image-20250405172052564"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172109700.png" alt="image-20250405172109700"></p>
<p>具体步骤：</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172145471.png" alt="image-20250405172145471"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172153998.png" alt="image-20250405172153998"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172208946.png" alt="image-20250405172208946"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172347010.png" alt="image-20250405172347010"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250405172357526.png" alt="image-20250405172357526"></p>
<h3 id="2-4-ALU"><a href="#2-4-ALU" class="headerlink" title="2.4 ALU"></a>2.4 ALU</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406110555945.png" alt="image-20250406110555945"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406110852706.png" alt="image-20250406110852706"></p>
<p>The Hack ALU</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406111036333.png" alt="image-20250406111036333"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406111128678.png" alt="image-20250406111128678"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406111445256.png" alt="image-20250406111445256"></p>
<h4 id="The-Hack-ALU-operation"><a href="#The-Hack-ALU-operation" class="headerlink" title="The Hack ALU operation"></a>The Hack ALU operation</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406111650538.png" alt="image-20250406111650538"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406111659071.png" alt="image-20250406111659071"></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406112032655.png" alt="image-20250406112032655"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406112211405.png" alt="image-20250406112211405"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406112814587.png" alt="image-20250406112814587"></p>
<h4 id="zr-ng-other-control-bits"><a href="#zr-ng-other-control-bits" class="headerlink" title="zr,ng(other control bits)"></a>zr,ng(other control bits)</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406113216863.png" alt="image-20250406113216863"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406113424794.png" alt="image-20250406113424794"></p>
<h3 id="2-5-Project-2-Overview"><a href="#2-5-Project-2-Overview" class="headerlink" title="2.5 Project 2 Overview"></a>2.5 Project 2 Overview</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115407406.png" alt="image-20250406115407406"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115505314.png" alt="image-20250406115505314"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115619723.png" alt="image-20250406115619723"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115813870.png" alt="image-20250406115813870"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115848432.png" alt="image-20250406115848432"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406115943371.png" alt="image-20250406115943371"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250406120143252.png" alt="image-20250406120143252"></p>
<h3 id="2-6-code"><a href="#2-6-code" class="headerlink" title="2.6 code"></a>2.6 code</h3><h4 id="HalfAdder"><a href="#HalfAdder" class="headerlink" title="HalfAdder"></a>HalfAdder</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/1bbe5e2afb8e3660effe1112926c7ef.jpg" alt="1bbe5e2afb8e3660effe1112926c7ef" style="zoom:10%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Computes the sum of two bits.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">CHIP HalfAdder &#123;</span><br><span class="line">    IN a, b;    // 1-bit inputs</span><br><span class="line">    OUT sum,    // Right bit of a + b </span><br><span class="line">        carry;  // Left bit of a + b</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Xor(a=a , b=b , out =sum );</span><br><span class="line">    And(a=a , b=b , out=carry );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FullAdder"><a href="#FullAdder" class="headerlink" title="FullAdder"></a>FullAdder</h4><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/d0e82880f0fd2ae54e547126bf44e45.jpg" alt="d0e82880f0fd2ae54e547126bf44e45" style="zoom:12%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Computes the sum of three bits.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">CHIP FullAdder &#123;</span><br><span class="line">    IN a, b, c;  </span><br><span class="line">    OUT sum,     </span><br><span class="line">        carry;   </span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Xor(a=a , b=b , out=xorab );</span><br><span class="line">    Xor(a=xorab , b=c , out=sum );</span><br><span class="line">    </span><br><span class="line">    And(a=a , b=b , out=andab );</span><br><span class="line">    Xor(a =a , b =b , out =xor2ab );</span><br><span class="line">    And(a=xor2ab , b=c , out=andcc );</span><br><span class="line">    Or(a=andab , b=andcc , out=carry );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Add16"><a href="#Add16" class="headerlink" title="Add16"></a>Add16</h4><p><img src="https://th.bing.com/th/id/OIP.eBsFkGOXIwb2W-vw9H2ICAHaDx?rs=1&pid=ImgDetMain" alt="Add16 · Nand2tetris-Homework"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 16-bit adder: Adds two 16-bit two&#x27;s complement values.</span><br><span class="line"> * The most significant carry bit is ignored.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">CHIP Add16 &#123;</span><br><span class="line">    IN a[16], b[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    HalfAdder(a=a[0] , b=b[0] , sum=out[0] , carry=c0 );</span><br><span class="line">    FullAdder(a=a[1] , b=b[1] , c=c0 , sum=out[1] , carry=c1 );</span><br><span class="line">    FullAdder(a=a[2] , b=b[2] , c=c1, sum=out[2] , carry=c2 );</span><br><span class="line">    FullAdder(a=a[3] , b=b[3] , c=c2 , sum=out[3] , carry=c3 );</span><br><span class="line">    FullAdder(a=a[4] , b=b[4] , c=c3 , sum=out[4] , carry=c4 );</span><br><span class="line">    FullAdder(a=a[5] , b=b[5] , c=c4 , sum=out[5] , carry=c5 );</span><br><span class="line">    FullAdder(a=a[6] , b=b[6] , c=c5 , sum=out[6] , carry=c6 );</span><br><span class="line">    FullAdder(a=a[7] , b=b[7] , c=c6 , sum=out[7] , carry=c7 );</span><br><span class="line">    FullAdder(a=a[8] , b=b[8] , c=c7 , sum=out[8] , carry=c8 );</span><br><span class="line">    FullAdder(a=a[9] , b=b[9] , c=c8 , sum=out[9] , carry=c9 );</span><br><span class="line">    FullAdder(a=a[10] , b=b[10] , c=c9 , sum=out[10] , carry=c10 );</span><br><span class="line">    FullAdder(a=a[11] , b=b[11] , c=c10 , sum=out[11] , carry=c11 );</span><br><span class="line">    FullAdder(a=a[12] , b=b[12] , c=c11 , sum=out[12] , carry=c12 );</span><br><span class="line">    FullAdder(a=a[13] , b=b[13] , c=c12 , sum=out[13] , carry=c13 );</span><br><span class="line">    FullAdder(a=a[14] , b=b[14] , c=c13 , sum=out[14] , carry=c14 );</span><br><span class="line">    FullAdder(a=a[15] , b=b[15] , c=c14 , sum=out[15] , carry=c15 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Inc16"><a href="#Inc16" class="headerlink" title="Inc16"></a>Inc16</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 16-bit incrementer:</span><br><span class="line"> * out = in + 1</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">CHIP Inc16 &#123;</span><br><span class="line">    IN in[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    HalfAdder(a=in[0] , b=true , sum=out[0] , carry=c0 );</span><br><span class="line">    FullAdder(a=in[1] , b=false , c=c0 , sum=out[1] , carry=c1 );</span><br><span class="line">    FullAdder(a=in[2] , b=false , c=c1, sum=out[2] , carry=c2 );</span><br><span class="line">    FullAdder(a=in[3] , b=false , c=c2 , sum=out[3] , carry=c3 );</span><br><span class="line">    FullAdder(a=in[4] , b=false , c=c3 , sum=out[4] , carry=c4 );</span><br><span class="line">    FullAdder(a=in[5] , b=false , c=c4 , sum=out[5] , carry=c5 );</span><br><span class="line">    FullAdder(a=in[6] , b=false , c=c5 , sum=out[6] , carry=c6 );</span><br><span class="line">    FullAdder(a=in[7] , b=false , c=c6 , sum=out[7] , carry=c7 );</span><br><span class="line">    FullAdder(a=in[8] , b=false , c=c7 , sum=out[8] , carry=c8 );</span><br><span class="line">    FullAdder(a=in[9] , b=false , c=c8 , sum=out[9] , carry=c9 );</span><br><span class="line">    FullAdder(a=in[10] , b=false , c=c9 , sum=out[10] , carry=c10 );</span><br><span class="line">    FullAdder(a=in[11] , b=false , c=c10 , sum=out[11] , carry=c11 );</span><br><span class="line">    FullAdder(a=in[12] , b=false , c=c11 , sum=out[12] , carry=c12 );</span><br><span class="line">    FullAdder(a=in[13] , b=false , c=c12 , sum=out[13] , carry=c13 );</span><br><span class="line">    FullAdder(a=in[14] , b=false , c=c13 , sum=out[14] , carry=c14 );</span><br><span class="line">    FullAdder(a=in[15] , b=false , c=c14 , sum=out[15] , carry=c15 );   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ALU (Arithmetic Logic Unit):</span><br><span class="line"> * Computes out = one of the following functions:</span><br><span class="line"> *                0, 1, -1,</span><br><span class="line"> *                x, y, !x, !y, -x, -y,</span><br><span class="line"> *                x + 1, y + 1, x - 1, y - 1,</span><br><span class="line"> *                x + y, x - y, y - x,</span><br><span class="line"> *                x &amp; y, x | y</span><br><span class="line"> * on the 16-bit inputs x, y,</span><br><span class="line"> * according to the input bits zx, nx, zy, ny, f, no.</span><br><span class="line"> * In addition, computes the two output bits:</span><br><span class="line"> * if (out == 0) zr = 1, else zr = 0</span><br><span class="line"> * if (out &lt; 0)  ng = 1, else ng = 0</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// Implementation: Manipulates the x and y inputs</span><br><span class="line">// and operates on the resulting values, as follows:</span><br><span class="line">// if (zx == 1) sets x = 0        // 16-bit constant</span><br><span class="line">// if (nx == 1) sets x = !x       // bitwise not</span><br><span class="line">// if (zy == 1) sets y = 0        // 16-bit constant</span><br><span class="line">// if (ny == 1) sets y = !y       // bitwise not</span><br><span class="line">// if (f == 1)  sets out = x + y  // integer 2&#x27;s complement addition</span><br><span class="line">// if (f == 0)  sets out = x &amp; y  // bitwise and</span><br><span class="line">// if (no == 1) sets out = !out   // bitwise not</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/3f83a46c9a79a5e0cb1a05e2188f621.jpg" alt="3f83a46c9a79a5e0cb1a05e2188f621" style="zoom: 18%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP ALU &#123;</span><br><span class="line">    IN  </span><br><span class="line">        x[16], y[16],  // 16-bit inputs        </span><br><span class="line">        zx, // zero the x input?</span><br><span class="line">        nx, // negate the x input?</span><br><span class="line">        zy, // zero the y input?</span><br><span class="line">        ny, // negate the y input?</span><br><span class="line">        f,  // compute (out = x + y) or (out = x &amp; y)?</span><br><span class="line">        no; // negate the out output?</span><br><span class="line">    OUT </span><br><span class="line">        out[16], // 16-bit output</span><br><span class="line">        zr,      // if (out == 0) equals 1, else 0</span><br><span class="line">        ng;      // if (out &lt; 0)  equals 1, else 0</span><br><span class="line"></span><br><span class="line">    PARTS:    </span><br><span class="line">    // zx</span><br><span class="line">    Mux16(a=x , b=false , sel=zx , out=x1 );</span><br><span class="line">    </span><br><span class="line">    // nx</span><br><span class="line">    Not16(in=x1 , out=notx );</span><br><span class="line">    Mux16(a=x1 , b=notx , sel=nx , out=x2 );</span><br><span class="line">    </span><br><span class="line">    // zy</span><br><span class="line">    Mux16(a=y , b=false , sel=zy , out=y1 );</span><br><span class="line">    </span><br><span class="line">    // ny</span><br><span class="line">    Not16(in=y1 , out=noty );</span><br><span class="line">    Mux16(a=y1 , b=noty , sel=ny , out=y2 );</span><br><span class="line">    </span><br><span class="line">    // f</span><br><span class="line">    Add16(a =x2 , b =y2 , out =add ); //+ 是 按位加 运算add</span><br><span class="line">    And16(a=x2 , b=y2 , out=and ); // &amp; 是 按位与 运算and</span><br><span class="line">    Mux16(a=and , b=add , sel=f , out=l1 );</span><br><span class="line">    </span><br><span class="line">    // no</span><br><span class="line">    Not16(in=l1 , out=l2 );</span><br><span class="line">    Mux16(a=l1, b=l2, sel=no, out=out,out[0..7]=kk1, out[8..15]=kk2, out[15]=kk);</span><br><span class="line">    // kk是精华 ！</span><br><span class="line">    </span><br><span class="line">    // zr</span><br><span class="line">    Or8Way(in=kk1, out=zr1);</span><br><span class="line">    Or8Way(in=kk2, out=zr2);</span><br><span class="line">    Or(a=zr1, b=zr2, out=zrNot);</span><br><span class="line">    Not(in=zrNot, out=zr);</span><br><span class="line"></span><br><span class="line">    // ng</span><br><span class="line">    Mux(a=false, b=kk, sel=zrNot, out=ng); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello world2</title>
    <url>/2025/04/19/text/</url>
    <content><![CDATA[<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/Rplot05.png"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>proj3</title>
    <url>/2025/05/02/nand2tetris-proj3-final-2/</url>
    <content><![CDATA[<h3 id="3-1-Sequential-Logic（逻辑时序）"><a href="#3-1-Sequential-Logic（逻辑时序）" class="headerlink" title="3.1 Sequential Logic（逻辑时序）"></a>3.1 Sequential Logic（逻辑时序）</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407103408721.png" alt="image-20250407103408721"></p>
<h4 id="The-Clock"><a href="#The-Clock" class="headerlink" title="The Clock"></a>The Clock</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407103559711.png" alt="image-20250407103559711"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407103651219.png" alt="image-20250407103651219"></p>
<p>⭐</p>
<h4 id="Combinatorial-Logic-vs-Sequential-Logic"><a href="#Combinatorial-Logic-vs-Sequential-Logic" class="headerlink" title="Combinatorial Logic vs. Sequential Logic"></a>Combinatorial Logic vs. Sequential Logic</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407104103457.png" alt="image-20250407104103457"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407104118222.png" alt="image-20250407104118222"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407104217914.png" alt="image-20250407104217914"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407104323702.png" alt="image-20250407104323702"></p>
<h3 id="3-2-Flip-Flops-触发器"><a href="#3-2-Flip-Flops-触发器" class="headerlink" title="3.2 Flip Flops 触发器"></a>3.2 Flip Flops 触发器</h3><p>制作：允许上一步操作的芯片</p>
<p>⭐</p>
<h4 id="D-触发器"><a href="#D-触发器" class="headerlink" title="D 触发器"></a><strong>D 触发器</strong></h4><p><strong>换句话说，DFF 简单地将前一个时间周期的输入值作为当前周期的输出。𝑜𝑢𝑡(𝑡)&#x3D;𝑖𝑛(𝑡−1)</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131732664.png" alt="image-20250407131732664"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407125650242.png" alt="image-20250407125650242"></p>
<h4 id="时序逻辑的原理"><a href="#时序逻辑的原理" class="headerlink" title="时序逻辑的原理"></a><strong>时序逻辑的原理</strong></h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407130044516.png" alt="image-20250407130044516"></p>
<h4 id="寄存器-Bit"><a href="#寄存器-Bit" class="headerlink" title="寄存器 Bit"></a>寄存器 Bit</h4><p>【寄存器（也）是一种常用的时序逻辑电路】</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407130252903.png" alt="image-20250407130252903"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407130512040.png" alt="image-20250407130512040"></p>
<h4 id="implement"><a href="#implement" class="headerlink" title="implement"></a>implement</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407130642446.png" alt="image-20250407130642446"></p>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131134475.png" alt="image-20250407131134475"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131141487.png" alt="image-20250407131141487"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131153974.png" alt="image-20250407131153974"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131219341.png" alt="image-20250407131219341"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131249812.png" alt="image-20250407131249812"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407131306313.png" alt="image-20250407131306313"></p>
<h3 id="3-3-Memory-Units"><a href="#3-3-Memory-Units" class="headerlink" title="3.3 Memory Units"></a>3.3 Memory Units</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407162440343.png" alt="image-20250407162440343"></p>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407162636276.png" alt="image-20250407162636276"></p>
<h4 id="The-most-basic-memory-element-Register"><a href="#The-most-basic-memory-element-Register" class="headerlink" title="The most basic memory element: Register"></a>The most basic memory element: Register</h4><p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250407162706895.png" alt="image-20250407162706895"></p>
<p>⭐ （并着排列的）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407162832550.png" alt="image-20250407162832550"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407163056209.png" alt="image-20250407163056209"></p>
<h4 id="RAM-unit"><a href="#RAM-unit" class="headerlink" title="RAM unit"></a>RAM unit</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407163925696.png" alt="image-20250407163925696"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164114314.png" alt="image-20250407164114314"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164124566.png" alt="image-20250407164124566"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164321731.png" alt="image-20250407164321731"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164328029.png" alt="image-20250407164328029"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164336551.png" alt="image-20250407164336551"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164355607.png" alt="image-20250407164355607"></p>
<p>（逻辑时序的芯片）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164409494.png" alt="image-20250407164409494"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164444136.png" alt="image-20250407164444136"></p>
<h4 id="RAM-Read-Logic"><a href="#RAM-Read-Logic" class="headerlink" title="RAM &#x2F; Read Logic"></a>RAM &#x2F; Read Logic</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164613906.png" alt="image-20250407164613906"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164723446.png" alt="image-20250407164723446"></p>
<h4 id="RAM-Write-Logic"><a href="#RAM-Write-Logic" class="headerlink" title="RAM &#x2F; Write Logic"></a>RAM &#x2F; Write Logic</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407164822467.png" alt="image-20250407164822467"></p>
<h4 id="A-family-of-16-bit-RAM-chips"><a href="#A-family-of-16-bit-RAM-chips" class="headerlink" title="A family of 16-bit RAM chips"></a>A family of 16-bit RAM chips</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407165748845.png" alt="image-20250407165748845"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407165903504.png" alt="image-20250407165903504"></p>
<h3 id="3-4-Counters"><a href="#3-4-Counters" class="headerlink" title="3.4  Counters"></a>3.4  Counters</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407183128147.png" alt="image-20250407183128147"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407183216165.png" alt="image-20250407183216165"></p>
<p>(Inc 代表增量[+1])</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250407183416972.png" alt="image-20250407183416972"></p>
<h3 id="3-5-code"><a href="#3-5-code" class="headerlink" title="3.5 code"></a>3.5 code</h3><h4 id="preview：DFF"><a href="#preview：DFF" class="headerlink" title="preview：DFF"></a>preview：DFF</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250415121843294.png" alt="image-20250415121843294"></p>
<hr>
<h4 id="1-bit-register-芯片"><a href="#1-bit-register-芯片" class="headerlink" title="1-bit register 芯片"></a>1-bit register 芯片</h4><ul>
<li>输入一个1-bit的数。如果load&#x3D;1，下一秒输入该数，如果load&#x3D;0，下一秒保持原来的数值。</li>
<li>register 中文：<strong>寄存器</strong></li>
</ul>
<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250415122014364.png" alt="image-20250415122014364" style="zoom:80%;" />

<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250415122027636.png" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Bit &#123;</span><br><span class="line">    IN in, load;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Mux(a=out2 , b=in , sel=load , out=w1 );</span><br><span class="line">    DFF(in=w1 , out=out,out=out2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="16-bit-register-芯片"><a href="#16-bit-register-芯片" class="headerlink" title="16-bit register 芯片"></a>16-bit register 芯片</h4><ul>
<li>输入一个16-bit的数。根据load，下一秒输出该数，或者下一秒保持上一秒的值。</li>
<li>1个load决定16个输出。16个1-bit register芯片并排。</li>
<li>对每一位进行load运算</li>
<li>最终的输入&#x2F;输出 都是 <strong>一个</strong> 16-bit的数</li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/OIP-C%20(1).jpg"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/OIP-C%20(3).jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit 寄存器! </span><br><span class="line">CHIP Register &#123;</span><br><span class="line">    IN in[16], load;</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    //对16bit的每一位进行load，当load为1的时候给 对应位 储存值</span><br><span class="line">    Bit(in=in[15] , load=load , out=out[15] );</span><br><span class="line">    Bit(in=in[14] , load=load , out=out[14] );</span><br><span class="line">    Bit(in=in[13] , load=load , out=out[13] );</span><br><span class="line">    Bit(in=in[12] , load=load , out=out[12] );</span><br><span class="line">    Bit(in=in[11] , load=load , out=out[11] );</span><br><span class="line">    Bit(in=in[10] , load=load , out=out[10] );</span><br><span class="line">    Bit(in=in[9] , load=load , out=out[9] );</span><br><span class="line">    Bit(in=in[8] , load=load , out=out[8] );</span><br><span class="line">    Bit(in=in[7] , load=load , out=out[7] );</span><br><span class="line">    Bit(in=in[6] , load=load , out=out[6] );</span><br><span class="line">    Bit(in=in[5] , load=load , out=out[5] );</span><br><span class="line">    Bit(in=in[4] , load=load , out=out[4] );</span><br><span class="line">    Bit(in=in[3] , load=load , out=out[3] );</span><br><span class="line">    Bit(in=in[2] , load=load , out=out[2] );</span><br><span class="line">    Bit(in=in[1] , load=load , out=out[1] );</span><br><span class="line">    Bit(in=in[0] , load=load , out=out[0] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAM8"><a href="#RAM8" class="headerlink" title="RAM8"></a>RAM8</h4><ul>
<li>8个 16-bit寄存器，并排放在RAM8里。</li>
<li>输入：<strong>一个</strong>16-bit 的数。输出为 <strong>一个</strong> 16-bit 的数  （<strong>数最大 16-bit</strong>，可小点）</li>
<li>⭐根据三位数地址address决定给    哪<strong>一个</strong>   register储存值。</li>
<li>对应的被调到的寄存器的load会被打开，load&#x3D;1。</li>
</ul>
<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82Njg0OTktNzY0NDYzZDgxYjExYWI4Mi5qcGc.png" style="zoom: 33%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP RAM8 &#123;</span><br><span class="line">    IN in[16], load, address[3];  // address有3位，能解码成 2的三次方= 8个 不一样的 三位数</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    //假设address为000，load为 1。DMux8Way会把load信号分配到输出端口a，</span><br><span class="line">    //也就是第一个寄存器的load端口会接收到值为 1 的信号，而其余寄存器的load端口会接收到值为 0 的信号（即不改变自身的值）</span><br><span class="line">    DMux8Way(in = load,sel = address,a = a,b = b,c = c,d = d,e = e,f = f,g = g,h = h);</span><br><span class="line"></span><br><span class="line">    Register(in=in , load=a , out=outa );</span><br><span class="line">    Register(in=in , load=b , out=outb );</span><br><span class="line">    Register(in=in , load=c , out=outc );</span><br><span class="line">    Register(in=in , load=d , out=outd );</span><br><span class="line">    Register(in=in , load=e , out=oute );</span><br><span class="line">    Register(in=in , load=f , out=outf );</span><br><span class="line">    Register(in=in , load=g , out=outg );</span><br><span class="line">    Register(in=in , load=h , out=outh );</span><br><span class="line"></span><br><span class="line">    Mux8Way16(a=outa , b=outb , c=outc , d=outd , e=oute , f=outf , g=outg , h=outh , sel=address , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAM64"><a href="#RAM64" class="headerlink" title="RAM64"></a>RAM64</h4><ul>
<li><strong>原理同RAM8：一个最大16-bit的输入，根据address（解码后）决定把改 一位数值 保存在哪个地方（该地方的load会打开）</strong></li>
<li>（结构由 8个RAM8 并排拼一起，解码端口变多了点，当然了address也长了点）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> CHIP RAM64 &#123;</span><br><span class="line">    IN in[16], load, address[6];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux8Way(in = load,sel = address[3..5],a = a,b = b,c = c,d = d,e = e,f = f,g = g,h = h);</span><br><span class="line">    //两层解码：第一层，用前3位区分开8个不一样的RAM8</span><br><span class="line"></span><br><span class="line">	// 第二层，用后三位，区分开来每个RAM8的8个不同的寄存器。（这样子就区分开来了8*8=64个寄存器）</span><br><span class="line">    RAM8(in=in , load=a , address=address[0..2] , out=outa );</span><br><span class="line">    RAM8(in=in , load=b , address=address[0..2] , out=outb );</span><br><span class="line">    RAM8(in=in , load=c , address=address[0..2] , out=outc );</span><br><span class="line">    RAM8(in=in , load=d , address=address[0..2] , out=outd );</span><br><span class="line">    RAM8(in=in , load=e , address=address[0..2] , out=oute );</span><br><span class="line">    RAM8(in=in , load=f , address=address[0..2] , out=outf );</span><br><span class="line">    RAM8(in=in , load=g , address=address[0..2] , out=outg );</span><br><span class="line">    RAM8(in=in , load=h , address=address[0..2] , out=outh );</span><br><span class="line"></span><br><span class="line">    Mux8Way16(a=outa , b=outb , c=outc , d=outd , e=oute , f=outf , g=outg , h=outh , sel=address[3..5] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAM512"><a href="#RAM512" class="headerlink" title="RAM512"></a>RAM512</h4><ul>
<li>原理同上，就是积木从小拼到大（8个RAM64）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP RAM512 &#123;</span><br><span class="line">    IN in[16], load, address[9];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux8Way(in = load,sel = address[6..8],a = a,b = b,c = c,d = d,e = e,f = f,g = g,h = h);</span><br><span class="line"></span><br><span class="line">    RAM64(in=in , load=a , address=address[0..5] , out=outa );</span><br><span class="line">    RAM64(in=in , load=b , address=address[0..5] , out=outb );</span><br><span class="line">    RAM64(in=in , load=c , address=address[0..5] , out=outc );</span><br><span class="line">    RAM64(in=in , load=d , address=address[0..5] , out=outd );</span><br><span class="line">    RAM64(in=in , load=e , address=address[0..5] , out=oute );</span><br><span class="line">    RAM64(in=in , load=f , address=address[0..5] , out=outf );</span><br><span class="line">    RAM64(in=in , load=g , address=address[0..5] , out=outg );</span><br><span class="line">    RAM64(in=in , load=h , address=address[0..5] , out=outh );</span><br><span class="line"></span><br><span class="line">    Mux8Way16(a=outa , b=outb , c=outc , d=outd , e=oute , f=outf , g=outg , h=outh , sel=address[6..8] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAM4K"><a href="#RAM4K" class="headerlink" title="RAM4K"></a>RAM4K</h4><ul>
<li>8个RAM512</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> CHIP RAM4K &#123;</span><br><span class="line">    IN in[16], load, address[12];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux8Way(in = load,sel = address[9..11],a = a,b = b,c = c,d = d,e = e,f = f,g = g,h = h);</span><br><span class="line">    //假设address为000，load为 1。DMux8Way会把load信号分配到输出端口a。</span><br><span class="line"></span><br><span class="line">    RAM512(in=in , load=a , address=address[0..8] , out=outa );</span><br><span class="line">    RAM512(in=in , load=b , address=address[0..8] , out=outb );</span><br><span class="line">    RAM512(in=in , load=c , address=address[0..8] , out=outc );</span><br><span class="line">    RAM512(in=in , load=d , address=address[0..8] , out=outd );</span><br><span class="line">    RAM512(in=in , load=e , address=address[0..8] , out=oute );</span><br><span class="line">    RAM512(in=in , load=f , address=address[0..8] , out=outf );</span><br><span class="line">    RAM512(in=in , load=g , address=address[0..8] , out=outg );</span><br><span class="line">    RAM512(in=in , load=h , address=address[0..8] , out=outh );</span><br><span class="line"></span><br><span class="line">    Mux8Way16(a=outa , b=outb , c=outc , d=outd , e=oute , f=outf , g=outg , h=outh , sel=address[9..11] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAM16K"><a href="#RAM16K" class="headerlink" title="RAM16K"></a>RAM16K</h4><ul>
<li>4个RAM4K</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> CHIP RAM16K &#123;</span><br><span class="line">    IN in[16], load, address[14];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux4Way(in = load,sel = address[12..13],a = a,b = b,c = c,d = d);</span><br><span class="line">    // 前两位用来区分4个RAM4K，后面12位是RAM4K所需的address。 </span><br><span class="line"></span><br><span class="line">    RAM4K(in=in , load=a , address=address[0..11] , out=outa );</span><br><span class="line">    RAM4K(in=in , load=b , address=address[0..11] , out=outb );</span><br><span class="line">    RAM4K(in=in , load=c , address=address[0..11] , out=outc );</span><br><span class="line">    RAM4K(in=in , load=d , address=address[0..11] , out=outd );</span><br><span class="line">    </span><br><span class="line">    Mux4Way16(a=outa , b=outb , c=outc , d=outd , sel=address[12..13] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250415131408114.png" alt="image-20250415131408114" style="zoom:50%;" />



<h4 id="CHIP-PC"><a href="#CHIP-PC" class="headerlink" title="CHIP PC"></a>CHIP PC</h4><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/747e5d538c8e16996b67320f42e7e77.jpg" alt="747e5d538c8e16996b67320f42e7e77"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A 16-bit counter. 计数器吧？？？</span><br><span class="line"> * if      reset(t): out(t+1) = 0</span><br><span class="line"> * else if load(t):  out(t+1) = in(t)</span><br><span class="line"> * else if inc(t):   out(t+1) = out(t) + 1</span><br><span class="line"> * else              out(t+1) = out(t)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">CHIP PC &#123;</span><br><span class="line">    IN in[16], reset, load, inc;</span><br><span class="line">    OUT out[16];</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line"></span><br><span class="line">    Inc16(in = feedback,out = incout);</span><br><span class="line">    Mux16(a = feedback,b = incout,sel = inc,out = out1);</span><br><span class="line">    Mux16(a = out1,b = in,sel = load,out = out2);</span><br><span class="line">    Mux16(a = out2,b = false,sel = reset,out = out3);</span><br><span class="line"></span><br><span class="line">    Register(in = out3,load = true,out = out,out = feedback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>nand2tetris</tag>
      </tags>
  </entry>
  <entry>
    <title>LOK</title>
    <url>/2025/04/11/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%972/</url>
    <content><![CDATA[<p><img src="https://picsum.photos/id/627/200/300" alt="图片名称八个字"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
</search>
