<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代码001</title>
    <url>/2025/04/10/hdh/</url>
    <content><![CDATA[<h2 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h2><h5 id="fgf"><a href="#fgf" class="headerlink" title="fgf"></a>fgf</h5><h2 id="fsfs"><a href="#fsfs" class="headerlink" title="fsfs"></a>fsfs</h2><h3 id="fgd"><a href="#fgd" class="headerlink" title="fgd"></a>fgd</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">z</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello wworld</title>
    <url>/2025/04/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>代码002</title>
    <url>/2025/04/15/nand2tetris-proj5-nopic/</url>
    <content><![CDATA[<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="RAM16K，Screen，Keyboard"><a href="#RAM16K，Screen，Keyboard" class="headerlink" title="RAM16K，Screen，Keyboard"></a>RAM16K，Screen，Keyboard</h3><blockquote>
<p>background</p>
</blockquote>
<ul>
<li><p><strong>8K &#x3D; 2的13次方。16K &#x3D; 2的14次方。</strong></p>
</li>
<li><p><strong>address[15] 表示 address 是一个 16 位的信号。</strong>address[15] 是第 1 位，<strong>address[0] 就是第 16 位。</strong></p>
</li>
<li><p><strong>RAM16K 的地址范围</strong>:**(16K)**（0到16383)需要 14 位地址来唯一标识每个存储单元，即 address[0..13] 这 14 位地址。</p>
</li>
<li><p><strong>Screen 的地址范围</strong>：**(8K)**（16384-24575）需要使用 13 位地址（address[0..12]）就可以满足其寻址需求。</p>
</li>
<li><p>可以明显看出，一个地址如果在0-16383内，它就属于 RAM16K 的地址空间；如果在16384-24575内，它就属于 Screen 的地址空间。所以<strong>它们的地址是分开的，没有重合。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP RAM16K &#123;</span><br><span class="line">    IN in[16], load, address[14];</span><br><span class="line">    OUT out[16];</span><br><span class="line">    // RAM16K是一个存储器，由16千个16-bit寄存器组成。</span><br><span class="line">    // 每次输入一个16位的数，RAM16K会根据其address决定将其存储到哪个位置。</span><br><span class="line">    // 具体的地址决定方法是：根据address的高2位（address[12..13]）选择一个4K的存储块，</span><br><span class="line">    // 然后根据低12位（address[0..11]）在所选的4K块内确定具体的存储位置。（以此类推，找到the only one）</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux4Way(in = load,sel = address[12..13],a = a,b = b,c = c,d = d);</span><br><span class="line">  </span><br><span class="line">    RAM4K(in=in , load=a , address=address[0..11] , out=outa );</span><br><span class="line">    RAM4K(in=in , load=b , address=address[0..11] , out=outb );</span><br><span class="line">    RAM4K(in=in , load=c , address=address[0..11] , out=outc );</span><br><span class="line">    RAM4K(in=in , load=d , address=address[0..11] , out=outd );</span><br><span class="line">    </span><br><span class="line">    Mux4Way16(a=outa , b=outb , c=outc , d=outd , sel=address[12..13] , out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Screen &#123;</span><br><span class="line"></span><br><span class="line">    IN  in[16],    // what to write</span><br><span class="line">    load,          // write-enable bit</span><br><span class="line">    address[13];   // where to read/write</span><br><span class="line">    OUT out[16];   // Screen value at the given address</span><br><span class="line"></span><br><span class="line">    BUILTIN Screen;</span><br><span class="line">    CLOCKED in, load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Keyboard&#123;</span><br><span class="line">    OUT out[16];</span><br><span class="line">    BUILTIN keyboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><img src="C:\Users\99512\Downloads\微信图片_20250415180524.jpg"  />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Memory &#123;</span><br><span class="line">    IN in[16], load, address[15];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux4Way(in=load, sel=address[13..14], a=ram1, b=ram2, c=scrn, d=keybd);</span><br><span class="line">    Or(a=ram1 , b=ram2, out=ram3);</span><br><span class="line">    RAM16K(in=in, load=ram3, address=address[0..13], out=ram );</span><br><span class="line">    Screen(in=in, load=scrn, address=address[0..12], out=sc);</span><br><span class="line">    Keyboard(out=kbd);</span><br><span class="line">    Mux4Way16(a=ram, b=ram, c=sc, d=kbd, sel=address[13..14], out=out);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414122921132.png" alt="image-20250414122921132" style="zoom:25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414123504372.png" alt="image-20250414123504372" style="zoom:25%;" /></p>
<p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250408152923618.png" alt="image-20250408152923618" style="zoom:25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250406111659071.png" alt="image-20250406111659071" style="zoom:25%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP CPU &#123;</span><br><span class="line"></span><br><span class="line">    IN  inM[16],         // M value input  (M = contents of RAM[A])</span><br><span class="line">        instruction[16], // Instruction for execution</span><br><span class="line">        reset;           // Signals whether to re-start the current</span><br><span class="line">                         // program (reset==1) or continue executing</span><br><span class="line">                         // the current program (reset==0).</span><br><span class="line"></span><br><span class="line">    OUT outM[16],        // M value output</span><br><span class="line">        writeM,          // Write to M? </span><br><span class="line">        addressM[15],    // Address in data memory (of M)</span><br><span class="line">        pc[15];          // address of next instruction</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">	// A-register 可能执行 A/C 指令</span><br><span class="line">    // A instruction</span><br><span class="line">    // @3001</span><br><span class="line">    // [0]000101110111001</span><br><span class="line">     </span><br><span class="line">     // 用途一：将常数输入计算机</span><br><span class="line">     // 用途二：为 C - 指令提供目标数据内存单元的地址（放入 A 寄存器）</span><br><span class="line">     // 用途三：为跳转指令提供目的地址</span><br><span class="line">    </span><br><span class="line">    Not(in=instruction[15] , out=notop ); </span><br><span class="line">    Mux16(a=aluOut, b=instruction , sel=notop , out=q1 ); 	 </span><br><span class="line">    Or(a=instruction[5] , b=notop , out=intoA );  </span><br><span class="line">    ARegister(in=q1, load=intoA, out=A,out[0..14]=addressM); // 同时储存并输出addressM </span><br><span class="line">    		</span><br><span class="line">    And(a=instruction[15] , b=instruction[12] , out=AMSwitch ); </span><br><span class="line">    Mux16(a=A , b=inM , sel=AMSwitch , out=AM );</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    // C instruction</span><br><span class="line">    // i  _  _  a  c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3</span><br><span class="line">    // 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00</span><br><span class="line">    // ins[5]是C指令中的dest指令(=1表示去A寄存器)</span><br><span class="line">    // ins[12]是a=0/1，用于在 C指令中 决定是使用 A寄存器的值（A）还是内存的值（inM）（A指令时直接用inM了）</span><br><span class="line">    </span><br><span class="line">    And(a=instruction[15] , b=instruction[4] , out=intoD );</span><br><span class="line">    DRegister(in=aluOut , load=intoD , out=D ); // D 寄存器：for数据暂存</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\99512\Downloads\微信图片_20250415200024.jpg"></p>
<img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250408153509769.png" alt="image-20250408153509769"  />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // ALU</span><br><span class="line">    // ALU takes input from DRegister and from ARegister or inM</span><br><span class="line">    // addressM 是用来确定从哪里读取数据，而 inM 是实际读取到的数据。</span><br><span class="line">    // ALU的zx,nx,zy,ny,f,no这些控制信号是由操作码 c1 - c6 经过一定逻辑转换得到的，所以C指令进不去A寄存器，但是ALU也是能获得其操作码进行操作的。</span><br><span class="line">    ALU(x=D, y=AM, out=aluOut, out=outM,</span><br><span class="line">        zx=instruction[11],</span><br><span class="line">        nx=instruction[10],</span><br><span class="line">        zy=instruction[9],</span><br><span class="line">        ny=instruction[8],</span><br><span class="line">        f=instruction[7],</span><br><span class="line">        no=instruction[6],</span><br><span class="line">        zr=zrOut,</span><br><span class="line">        ng=ngOut</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // writeM</span><br><span class="line">    And(a=instruction[15] , b=instruction[3] , out=writeM );</span><br><span class="line"></span><br><span class="line">    // PC </span><br><span class="line">    // load设置</span><br><span class="line">    Not(in=ngOut , out=pos );</span><br><span class="line">    Not(in=zrOut , out=nzr );</span><br><span class="line"></span><br><span class="line">    // 处理JGT条件(&gt;0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[0] , out=jgt );</span><br><span class="line">    And(a=pos , b=nzr , out=posnzr );</span><br><span class="line">    And(a=jgt , b=posnzr , out=ld1 ); </span><br><span class="line"></span><br><span class="line">    // 处理JEQ条件(=0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[1] , out=jeq );</span><br><span class="line">    And(a=jeq , b=zrOut , out=ld2 ); </span><br><span class="line"></span><br><span class="line">    // 处理JLT条件(&lt;0 jump)</span><br><span class="line">    And(a=instruction[15] , b=instruction[2] , out=jlt );</span><br><span class="line">    And(a=jlt , b=ngOut , out=ld3 );</span><br><span class="line"></span><br><span class="line">    //合并跳转条件</span><br><span class="line">    Or(a=ld1 , b=ld2 , out=ldt ); </span><br><span class="line">    Or(a=ld3 , b=ldt , out=loadd );</span><br><span class="line"></span><br><span class="line">    PC(in=A , load=loadd , inc=true , reset=reset , out[0..14]=pc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 内存根据 PC 提供的地址，将对应地址处的指令输出为 instruction。</span><br><span class="line">// 但这并不是 PC 输出后被写入 RAM ，而是 PC 提供一个地址索引，内存根据这个索引将存储在该地址的指令数据输出。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414193356928.png" alt="image-20250414193356928" style="zoom: 25%;" /><img src="C:\Users\99512\AppData\Roaming\Typora\typora-user-images\image-20250414130853170.png" alt="image-20250414130853170" style="zoom:25%;" /></p>
<h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Computer &#123;</span><br><span class="line"></span><br><span class="line">    IN reset;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    ROM32K(address=pc , out=instruction );</span><br><span class="line">    CPU(inM=inM, instruction=instruction , reset=reset , outM=outM , writeM=writeM , addressM=addressM , pc=pc );</span><br><span class="line">    Memory(in=outM , load=writeM , address=addressM , out=inM );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>nand2tetris-proj1-final</title>
    <url>/2025/04/19/nand2tetris-proj1-final/</url>
    <content><![CDATA[<h2 id="Proj1"><a href="#Proj1" class="headerlink" title="Proj1"></a>Proj1</h2><h3 id="1-1-Boolean-Logic"><a href="#1-1-Boolean-Logic" class="headerlink" title="1.1 Boolean Logic"></a>1.1 Boolean Logic</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141214589.png" alt="image-20250404141214589"></p>
<p>⭐<strong>Some useful equations</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141414517.png" alt="image-20250404141414517"></p>
<p><strong>→Boolean Algebra  can be 化简</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141608949.png" alt="image-20250404141608949"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404141759670.png" alt="image-20250404141759670"></p>
<p>（Two way : ①equations,②write down the truth table)</p>
<h3 id="1-2-Boolean-Function"><a href="#1-2-Boolean-Function" class="headerlink" title="1.2 Boolean Function"></a>1.2 Boolean Function</h3><h5 id="001："><a href="#001：" class="headerlink" title="001："></a>001：</h5><ul>
<li><strong>理论上，任何布尔函数都可以用NotAndOr等表示出来（通过真值表选取f&#x3D;1的情况）（做芯片有用）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142330760.png" alt="image-20250404142330760"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142531366.png" alt="image-20250404142531366"></p>
<h5 id="002："><a href="#002：" class="headerlink" title="002："></a>002：</h5><ul>
<li><strong>（or可以通过And和Not表示）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142856026.png" alt="image-20250404142856026"></p>
<h5 id="003："><a href="#003：" class="headerlink" title="003："></a>003：</h5><ul>
<li><strong>而Nand可以表示出AndNot芯片（根本的根本）</strong></li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404142922081.png" alt="image-20250404142922081"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404144646895.png" alt="image-20250404144646895"></p>
<h3 id="1-3-Logic-Gates"><a href="#1-3-Logic-Gates" class="headerlink" title="1.3 Logic Gates"></a>1.3 Logic Gates</h3><p><em>上一节是抽象的逻辑运算，这一节是<strong>实际的</strong>芯片&#x2F;逻辑门</em></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145506478.png" alt="image-20250404145506478"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145701379.png" alt="image-20250404145701379"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145744036.png" alt="image-20250404145744036"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404145815647.png" alt="image-20250404145815647"></p>
<p><strong>一个接口，可以有不同的实现</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150147322.png" alt="image-20250404150147322"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150426261.png" alt="image-20250404150426261"></p>
<h3 id="1-4-Hardware-Description-Language"><a href="#1-4-Hardware-Description-Language" class="headerlink" title="1.4 Hardware Description Language"></a>1.4 Hardware Description Language</h3><p><strong>一种硬件描述语言（做硬件&#x2F;芯片用的）</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404150718865.png" alt="image-20250404150718865"></p>
<p><strong>芯片接口 和 芯片实现</strong></p>
<p>⭐<strong>实现：用真值表看1，写出布尔函数化简，画出逻辑图</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404151805805.png" alt="image-20250404151805805"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404152954069.png" alt="image-20250404152954069"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404153644134.png" alt="image-20250404153644134"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404154013569.png" alt="image-20250404154013569"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404154041022.png" alt="image-20250404154041022"></p>
<h3 id="1-5-Hardware-Simulation"><a href="#1-5-Hardware-Simulation" class="headerlink" title="1.5 Hardware Simulation"></a>1.5 Hardware Simulation</h3><ul>
<li><strong>for 模拟芯片测试</strong><ul>
<li>way：在给定的硬件模拟器中 + 使用编写的测试文件</li>
</ul>
</li>
</ul>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404160947915.png" alt="image-20250404160947915"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404163421803.png" alt="image-20250404163421803"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404170858647.png" alt="image-20250404170858647"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404172732071.png" alt="image-20250404172732071"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404172955446.png" alt="image-20250404172955446"></p>
<h3 id="1-6-Mutil-bit-Buses"><a href="#1-6-Mutil-bit-Buses" class="headerlink" title="1.6 Mutil-bit Buses"></a>1.6 Mutil-bit Buses</h3><p><strong>多位总线（eg16位总线，一条线上有16个位bit）</strong></p>
<p>（最左边第一位是高位。 最右边的最低位一般标记为第 0 位）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202521312.png" alt="image-20250404202521312"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202530048.png" alt="image-20250404202530048"></p>
<p><strong>⭐ useful</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202602223.png" alt="image-20250404202602223"></p>
<p>说明中第一句的意思是：<strong>可以进行多个output，比如前8位输出，后八位输出，全部输出</strong></p>
<h3 id="1-7-proj-7-preview"><a href="#1-7-proj-7-preview" class="headerlink" title="1.7 proj 7  preview"></a>1.7 proj 7  preview</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202849141.png" alt="image-20250404202849141"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404202926080.png" alt="image-20250404202926080"></p>
<p><strong>tip几个</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203025658.png" alt="image-20250404203025658"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203159712.png" alt="image-20250404203159712"></p>
<p>（既可以用作And门，也可以用作Mux门）</p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404203425278.png" alt="image-20250404203425278"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204239746.png" alt="image-20250404204239746"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204625628.png" alt="image-20250404204625628"></p>
<p><strong>And 16 ： 两个输入，都是16位的，一个输出（每位进行And运算），也是十六位的</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204739365.png" alt="image-20250404204739365"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404204849942.png" alt="image-20250404204849942"></p>
<p><strong>16-bit，4way multiplexor : 输入都是16位的，4个输入，一个16bit输出（mux逻辑，根据which sel进行选择）。</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404205018344.png" alt="image-20250404205018344"></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404205126035.png" alt="image-20250404205126035"></p>
<p>⭐ <strong>notes</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404210112492.png" alt="image-20250404210112492"></p>
<p> <strong>API</strong></p>
<p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/image-20250404211743753.png" alt="image-20250404211743753"></p>
<h3 id="1-8-code"><a href="#1-8-code" class="headerlink" title="1.8 code"></a>1.8 code</h3><h4 id="Nand"><a href="#Nand" class="headerlink" title="Nand"></a>Nand</h4><table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>out</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Not gate : if (in) out = 0, else out = 1</span><br><span class="line"></span><br><span class="line">CHIP Not &#123;</span><br><span class="line">    IN in;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=in, b=in, out=out);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="And"><a href="#And" class="headerlink" title="And"></a>And</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// And gate : if (a and b) out = 1, else out = 0 </span><br><span class="line"></span><br><span class="line">CHIP And &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=a, b=b, out=c);</span><br><span class="line">    Not(in=c,out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or"><a href="#Or" class="headerlink" title="Or"></a>Or</h4><img src="C:\Users\99512\Downloads\微信图片_20250419091434.jpg" style="zoom: 10%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Or gate : if (a or b) out = 1, else out = 0 </span><br><span class="line">// only a=0,b=0,out=0,else out=1</span><br><span class="line"></span><br><span class="line">CHIP Or &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Nand(a=a, b=a, out=a2);</span><br><span class="line">    Nand(a=b, b=b, out=b2);</span><br><span class="line">    Nand(a=a2, b=b2,out=out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Xor"><a href="#Xor" class="headerlink" title="Xor"></a>Xor</h4><img src="C:\Users\99512\Downloads\微信图片_20250419092342.jpg" style="zoom: 12%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exclusive-or gate: if ((a and Not(b)) or (Not(a) and b)) out = 1, else out = 0</span><br><span class="line"></span><br><span class="line">CHIP Xor &#123;</span><br><span class="line">    IN a, b;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    ////真值表推出来的(定义也写明了哈哈哈)</span><br><span class="line">    Not(in=a, out=nota);</span><br><span class="line">    Not(in=b, out=notb);</span><br><span class="line">    And(a=a, b=notb, out=aAndnotb);</span><br><span class="line">    And(a=b, b=nota, out=bAndnota);</span><br><span class="line">    Or(a=aAndnotb, b=bAndnota, out=out);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="Mux（二1bit并一）"><a href="#Mux（二1bit并一）" class="headerlink" title="Mux（二1bit并一）"></a>Mux（二1bit并一）</h4><img src="C:\Users\99512\Downloads\微信图片_20250419093334.jpg" style="zoom:10%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Multiplexor: if (sel = 0) out = a, else out = b  (good!)</span><br><span class="line"></span><br><span class="line">CHIP Mux &#123;</span><br><span class="line">    IN a, b, sel;</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel, out=notsel); </span><br><span class="line">    And(a=a , b=notsel, out=outa);//if sel==0,返回a (depend on a)</span><br><span class="line">    And(a=sel, b=b, out=outb ); //if sel==1，返回b (depend on b)</span><br><span class="line">    Or(a=outa, b=outb, out=out );   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dmux（一解二）"><a href="#Dmux（一解二）" class="headerlink" title="Dmux（一解二）"></a>Dmux（一解二）</h4><img src="C:\Users\99512\Downloads\微信图片_20250419094303.jpg" style="zoom:11%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Demultiplexor: [a, b] = 		[in, 0] if sel = 0 		[0, in] if sel = 1</span><br><span class="line"></span><br><span class="line">CHIP DMux &#123;</span><br><span class="line">    IN in, sel;</span><br><span class="line">    OUT a, b;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel , out=notsel );</span><br><span class="line">    And(a=in, b=notsel, out=a );</span><br><span class="line">    And(a=in, b=sel , out=b ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Not16"><a href="#Not16" class="headerlink" title="Not16"></a>Not16</h4><img src="C:\Users\99512\Downloads\微信图片_20250419094742.jpg" style="zoom:13%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit Not gate:		for i = 0, ..., 15: 	out[i] = Not(a[i])</span><br><span class="line"> </span><br><span class="line">// 把一个16位的数，每一位都取反</span><br><span class="line">CHIP Not16 &#123;</span><br><span class="line">    IN in[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=in[0] , out=out[0] );</span><br><span class="line">    Not(in=in[1] , out=out[1] );</span><br><span class="line">    Not(in=in[2] , out=out[2] );</span><br><span class="line">    Not(in=in[3] , out=out[3] );</span><br><span class="line">    Not(in=in[4] , out=out[4] );</span><br><span class="line">    Not(in=in[5] , out=out[5] );</span><br><span class="line">    Not(in=in[6] , out=out[6] );</span><br><span class="line">    Not(in=in[7] , out=out[7] );</span><br><span class="line">    Not(in=in[8] , out=out[8] );</span><br><span class="line">    Not(in=in[9] , out=out[9] );</span><br><span class="line">    Not(in=in[10] , out=out[10] );</span><br><span class="line">    Not(in=in[11] , out=out[11] );</span><br><span class="line">    Not(in=in[12] , out=out[12] );</span><br><span class="line">    Not(in=in[13] , out=out[13] );</span><br><span class="line">    Not(in=in[14] , out=out[14] );</span><br><span class="line">    Not(in=in[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="And16"><a href="#And16" class="headerlink" title="And16"></a>And16</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit And gate: 	for i = 0, ..., 15: 	out[i] = a[i] And b[i] </span><br><span class="line"></span><br><span class="line">// 把两个16位的数，每一位都求And</span><br><span class="line">CHIP And16 &#123;</span><br><span class="line">    IN a[16], b[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    //// Replace this comment with your code.</span><br><span class="line">    And(a=a[0] , b=b[0] , out=out[0] );</span><br><span class="line">    And(a=a[1] , b=b[1] , out=out[1] );</span><br><span class="line">    And(a=a[2] , b=b[2] , out=out[2] );</span><br><span class="line">    And(a=a[3] , b=b[3] , out=out[3] );</span><br><span class="line">    And(a=a[4] , b=b[4] , out=out[4] );</span><br><span class="line">    And(a=a[5] , b=b[5] , out=out[5] );</span><br><span class="line">    And(a=a[6] , b=b[6] , out=out[6] );</span><br><span class="line">    And(a=a[7] , b=b[7] , out=out[7] );</span><br><span class="line">    And(a=a[8] , b=b[8] , out=out[8] );</span><br><span class="line">    And(a=a[9] , b=b[9] , out=out[9] );</span><br><span class="line">    And(a=a[10] , b=b[10] , out=out[10] );</span><br><span class="line">    And(a=a[11] , b=b[11] , out=out[11] );</span><br><span class="line">    And(a=a[12] , b=b[12] , out=out[12] );</span><br><span class="line">    And(a=a[13] , b=b[13] , out=out[13] );</span><br><span class="line">    And(a=a[14] , b=b[14] , out=out[14] );</span><br><span class="line">    And(a=a[15] , b=b[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or16"><a href="#Or16" class="headerlink" title="Or16"></a>Or16</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit Or gate: 		for i = 0, ..., 15: 	out[i] = a[i] Or b[i] </span><br><span class="line"></span><br><span class="line">CHIP Or16 &#123;</span><br><span class="line">    IN a[16], b[16];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Or(a=a[0] , b=b[0] , out=out[0] );</span><br><span class="line">    Or(a=a[1] , b=b[1] , out=out[1] );</span><br><span class="line">    Or(a=a[2] , b=b[2] , out=out[2] );</span><br><span class="line">    Or(a=a[3] , b=b[3] , out=out[3] );</span><br><span class="line">    Or(a=a[4] , b=b[4] , out=out[4] );</span><br><span class="line">    Or(a=a[5] , b=b[5] , out=out[5] );</span><br><span class="line">    Or(a=a[6] , b=b[6] , out=out[6] );</span><br><span class="line">    Or(a=a[7] , b=b[7] , out=out[7] );</span><br><span class="line">    Or(a=a[8] , b=b[8] , out=out[8] );</span><br><span class="line">    Or(a=a[9] , b=b[9] , out=out[9] );</span><br><span class="line">    Or(a=a[10] , b=b[10] , out=out[10] );</span><br><span class="line">    Or(a=a[11] , b=b[11] , out=out[11] );</span><br><span class="line">    Or(a=a[12] , b=b[12] , out=out[12] );</span><br><span class="line">    Or(a=a[13] , b=b[13] , out=out[13] );</span><br><span class="line">    Or(a=a[14] , b=b[14] , out=out[14] );</span><br><span class="line">    Or(a=a[15] , b=b[15] , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux16（二16bit并一）"><a href="#Mux16（二16bit并一）" class="headerlink" title="Mux16（二16bit并一）"></a>Mux16（二16bit并一）</h4><ul>
<li>实现方式：16个Mux并排作用与每一个bit</li>
</ul>
<img src="C:\Users\99512\Downloads\微信图片_20250419095746.jpg" style="zoom:13%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 16-bit multiplexor: 		for i = 0, ..., 15:	   if (sel = 0) out[i] = a[i], else out[i] = b[i]</span><br><span class="line"></span><br><span class="line">CHIP Mux16 &#123;</span><br><span class="line">    IN a[16], b[16], sel;</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    Not(in=sel , out=notsel );</span><br><span class="line"></span><br><span class="line">    And(a=a[0] , b=notsel , out=out01 );</span><br><span class="line">    And(a=sel , b=b[0] , out=out02 );</span><br><span class="line">    Or(a=out01 , b=out02 , out=out[0] );</span><br><span class="line"></span><br><span class="line">    And(a=a[1] , b=notsel , out=out11 );</span><br><span class="line">    And(a=sel , b=b[1] , out=out12 );</span><br><span class="line">    Or(a=out11 , b=out12 , out=out[1] );</span><br><span class="line"></span><br><span class="line">    And(a=a[2] , b=notsel , out=out21 );</span><br><span class="line">    And(a=sel , b=b[2] , out=out22 );</span><br><span class="line">    Or(a=out21 , b=out22 , out=out[2] );</span><br><span class="line"></span><br><span class="line">    And(a=a[3] , b=notsel , out=out31 );</span><br><span class="line">    And(a=sel , b=b[3] , out=out32 );</span><br><span class="line">    Or(a=out31 , b=out32 , out=out[3] );</span><br><span class="line"></span><br><span class="line">    And(a=a[4] , b=notsel , out=out41 );</span><br><span class="line">    And(a=sel , b=b[4] , out=out42 );</span><br><span class="line">    Or(a=out41 , b=out42 , out=out[4] );</span><br><span class="line"></span><br><span class="line">    And(a=a[5] , b=notsel , out=out51 );</span><br><span class="line">    And(a=sel , b=b[5] , out=out52 );</span><br><span class="line">    Or(a=out51 , b=out52 , out=out[5] );</span><br><span class="line"></span><br><span class="line">    And(a=a[6] , b=notsel , out=out61 );</span><br><span class="line">    And(a=sel , b=b[6] , out=out62 );</span><br><span class="line">    Or(a=out61 , b=out62 , out=out[6] );</span><br><span class="line"></span><br><span class="line">    And(a=a[7] , b=notsel , out=out71 );</span><br><span class="line">    And(a=sel , b=b[7] , out=out72 );</span><br><span class="line">    Or(a=out71 , b=out72 , out=out[7] );</span><br><span class="line"></span><br><span class="line">    And(a=a[8] , b=notsel , out=out81 );</span><br><span class="line">    And(a=sel , b=b[8] , out=out82 );</span><br><span class="line">    Or(a=out81 , b=out82 , out=out[8] );</span><br><span class="line"></span><br><span class="line">    And(a=a[9] , b=notsel , out=out91 );</span><br><span class="line">    And(a=sel , b=b[9] , out=out92 );</span><br><span class="line">    Or(a=out91 , b=out92 , out=out[9] );</span><br><span class="line"></span><br><span class="line">    And(a=a[10] , b=notsel , out=out101 );</span><br><span class="line">    And(a=sel , b=b[10] , out=out102 );</span><br><span class="line">    Or(a=out101 , b=out102 , out=out[10] );</span><br><span class="line"></span><br><span class="line">    And(a=a[11] , b=notsel , out=out111 );</span><br><span class="line">    And(a=sel , b=b[11] , out=out112 );</span><br><span class="line">    Or(a=out111 , b=out112 , out=out[11] );</span><br><span class="line"></span><br><span class="line">    And(a=a[12] , b=notsel , out=out121 );</span><br><span class="line">    And(a=sel , b=b[12] , out=out122 );</span><br><span class="line">    Or(a=out121 , b=out122 , out=out[12] );</span><br><span class="line"></span><br><span class="line">    And(a=a[13] , b=notsel , out=out131 );</span><br><span class="line">    And(a=sel , b=b[13] , out=out132 );</span><br><span class="line">    Or(a=out131 , b=out132 , out=out[13] );</span><br><span class="line"></span><br><span class="line">    And(a=a[14] , b=notsel , out=out141 );</span><br><span class="line">    And(a=sel , b=b[14] , out=out142 );</span><br><span class="line">    Or(a=out141 , b=out142 , out=out[14] );</span><br><span class="line"></span><br><span class="line">    And(a=a[15] , b=notsel , out=out151 );</span><br><span class="line">    And(a=sel , b=b[15] , out=out152 );</span><br><span class="line">    Or(a=out151 , b=out152 , out=out[15] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Or8Way"><a href="#Or8Way" class="headerlink" title="Or8Way"></a>Or8Way</h4><img src="C:\Users\99512\Downloads\微信图片_20250419100705.jpg" style="zoom:10%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 8-way Or gate！  		out = in[0] Or in[1] Or ... Or in[7]</span><br><span class="line">// 输入 一个 8-bit数！而不是 两个 ！输出一个1-bit数。</span><br><span class="line"></span><br><span class="line">CHIP Or8Way &#123;</span><br><span class="line">    IN in[8];</span><br><span class="line">    OUT out;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    // 输入一个八位（bit）数，依次每两位取Or，最后输出结果（全0才会输出0，有一个1就输出1）</span><br><span class="line">    Or(a=in[0] , b=in[1] , out=s1 );</span><br><span class="line">    Or(a=in[2] , b=in[3] , out=s2 );</span><br><span class="line">    Or(a=in[4] , b=in[5] , out=s3 );</span><br><span class="line">    Or(a=in[6] , b=in[7] , out=s4 );</span><br><span class="line">    Or(a=s1 , b=s2 , out=w1 );</span><br><span class="line">    Or(a=s3 , b=s4 , out=w2 );</span><br><span class="line">    Or(a=w1 , b=w2 , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux4Way16（四16bit并一）"><a href="#Mux4Way16（四16bit并一）" class="headerlink" title="Mux4Way16（四16bit并一）"></a>Mux4Way16（四16bit并一）</h4><ul>
<li><p>解析名字含义：</p>
<ul>
<li><p><strong>Mux16</strong> 是 <strong>16-bit</strong> 的意思。</p>
</li>
<li><p><strong>Mux4Way16</strong> 是 <strong>16-bit，4-way</strong> 的意思</p>
</li>
<li><p>那为啥 Or8Way 是 8-bit，1-way？的意思？</p>
</li>
</ul>
</li>
</ul>
<img src="C:\Users\99512\Downloads\微信图片_20250419101933.jpg" style="zoom:12%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4-way 16-bit multiplexor:</span><br><span class="line"> * out = a if sel = 00</span><br><span class="line"> *       b if sel = 01</span><br><span class="line"> *       c if sel = 10</span><br><span class="line"> *       d if sel = 11</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 四条路/输入，每个都是16bit，根据sel的不同（4个sel，两位的二进制数字），输出其中 一 个数。</span><br><span class="line">CHIP Mux4Way16 &#123; 							// 看成 Mux 16 ，把 4Way 插在名字中间</span><br><span class="line">    IN a[16], b[16], c[16], d[16], sel[2];</span><br><span class="line">    OUT out[16];</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    // we just need one output !</span><br><span class="line">    Mux16(a=a , b=b , sel=sel[0] , out=w1 );   // [0]是最右</span><br><span class="line">    Mux16(a=c , b=d , sel=sel[0] , out=w2 );</span><br><span class="line"></span><br><span class="line">    Mux16(a=w1 , b=w2 , sel=sel[1] , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mux8Way16（八16bit并一）"><a href="#Mux8Way16（八16bit并一）" class="headerlink" title="Mux8Way16（八16bit并一）"></a>Mux8Way16（八16bit并一）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 8-way 16-bit multiplexor:</span><br><span class="line"> * out = a if sel = 000</span><br><span class="line"> *       b if sel = 001</span><br><span class="line"> *       c if sel = 010</span><br><span class="line"> *       d if sel = 011</span><br><span class="line"> *       e if sel = 100</span><br><span class="line"> *       f if sel = 101</span><br><span class="line"> *       g if sel = 110</span><br><span class="line"> *       h if sel = 111</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 8条路/输入，每个都是16bit，根据sel的不同（8个sel，三位的二进制数字），输出其中 一 个数。</span><br><span class="line">CHIP Mux8Way16 &#123;</span><br><span class="line">    IN a[16], b[16], c[16], d[16],</span><br><span class="line">       e[16], f[16], g[16], h[16],</span><br><span class="line">       sel[3];</span><br><span class="line">    OUT out[16];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    // 用两个Mux4Way16再加上一个Mux16就行了。</span><br><span class="line">    Mux4Way16(a=a , b=b , c=c , d=d , sel[0]=sel[0] ,sel[1]=sel[1],out=w1 );</span><br><span class="line">    Mux4Way16(a=e , b=f , c=g , d=h , sel[0]=sel[0] ,sel[1]=sel[1],out=w2 );</span><br><span class="line">    Mux16(a=w1 , b=w2 , sel=sel[2] , out=out );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMux4Way（一解四）"><a href="#DMux4Way（一解四）" class="headerlink" title="DMux4Way（一解四）"></a>DMux4Way（一解四）</h4><img src="C:\Users\99512\Downloads\微信图片_20250419103310.jpg" style="zoom:13%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4-way demultiplexor:</span><br><span class="line"> * [a, b, c, d] = [in, 0, 0, 0] if sel = 00</span><br><span class="line"> *                [0, in, 0, 0] if sel = 01</span><br><span class="line"> *                [0, 0, in, 0] if sel = 10</span><br><span class="line"> *                [0, 0, 0, in] if sel = 11</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 一个输入（几bit应该没要求），根据sel的不同选择赋予abcd哪个的值（4个值4Way，需要4个sel），其他值输出0（4个sel，两位二进制数字）</span><br><span class="line">CHIP DMux4Way &#123;</span><br><span class="line">    IN in, sel[2];</span><br><span class="line">    OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    DMux(in=in, sel=sel[1], a=top, b=bottom);</span><br><span class="line">    </span><br><span class="line">    DMux(in=top, sel=sel[0], a=a, b=b);</span><br><span class="line">    DMux(in=bottom, sel=sel[0], a=c, b=d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMux8Way（一解八）"><a href="#DMux8Way（一解八）" class="headerlink" title="DMux8Way（一解八）"></a>DMux8Way（一解八）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 8-way demultiplexor:</span><br><span class="line"> * [a, b, c, d, e, f, g, h] = [in, 0,  0,  0,  0,  0,  0,  0] if sel = 000</span><br><span class="line"> *                            [0, in,  0,  0,  0,  0,  0,  0] if sel = 001</span><br><span class="line"> *                            [0,  0, in,  0,  0,  0,  0,  0] if sel = 010</span><br><span class="line"> *                            [0,  0,  0, in,  0,  0,  0,  0] if sel = 011</span><br><span class="line"> *                            [0,  0,  0,  0, in,  0,  0,  0] if sel = 100</span><br><span class="line"> *                            [0,  0,  0,  0,  0, in,  0,  0] if sel = 101</span><br><span class="line"> *                            [0,  0,  0,  0,  0,  0, in,  0] if sel = 110</span><br><span class="line"> *                            [0,  0,  0,  0,  0,  0,  0, in] if sel = 111</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 根据三位数的sel把in分成8部分</span><br><span class="line">CHIP DMux8Way &#123;</span><br><span class="line">    IN in, sel[3];</span><br><span class="line">    // sel有8种可能，但打开时，只有一种状态，所以只有一个有值，其他都是0值。</span><br><span class="line">    OUT a, b, c, d, e, f, g, h;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    // 根据sel第一位，把in数据分成两部分，top和bottom</span><br><span class="line">    DMux(in=in, sel=sel[2], a=top, b=bottom);</span><br><span class="line"></span><br><span class="line">    // 根据sel第二位，分别把top和bottom再分成两个部分，总计四部分</span><br><span class="line">    DMux(in=top, sel=sel[1], a=w1, b=w2);</span><br><span class="line">    DMux(in=bottom, sel=sel[1], a=w3, b=w4);</span><br><span class="line"></span><br><span class="line">    // 根据sel第三位，把in总共分成8部分</span><br><span class="line">    DMux(in=w1, sel=sel[0], a=a, b=b);</span><br><span class="line">    DMux(in=w2, sel=sel[0], a=c, b=d);</span><br><span class="line"></span><br><span class="line">    DMux(in=w3, sel=sel[0], a=e, b=f);</span><br><span class="line">    DMux(in=w4, sel=sel[0], a=g, b=h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Hello wworld</title>
    <url>/2025/04/19/text/</url>
    <content><![CDATA[<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p><img src="https://dbddbdbdbd.oss-cn-qingdao.aliyuncs.com/Rplot05.png"></p>
]]></content>
  </entry>
  <entry>
    <title>LOK</title>
    <url>/2025/04/11/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%972/</url>
    <content><![CDATA[<p><img src="https://picsum.photos/id/627/200/300" alt="图片名称八个字"></p>
]]></content>
  </entry>
</search>
